#!/usr/bin/env ruby

# File header ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
#                                                                              ┃
# File informations:                                                           ┃
# - Name:    fizzy                                                             ┃
# - Summary: The hassle free configuration manager                             ┃
# - Authors:                                                                   ┃
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)              ┃
# - Contributors:                                                              ┃
#   - Luca Molari <molari.luca@gmail.com> (lmolr)                              ┃
#   Special thanks:                                                            ┃
#   - Thor project (https://github.com/erikhuda/thor)                          ┃
#   - Hash#deep_merge (http://www.ruby-forum.com/topic/142809)                 ┃
#                                                                              ┃
# Project informations:                                                        ┃
#   - Homepage:        https://github.com/alem0lars/fizzy                      ┃
#   - Getting started: see README.md in the project root folder                ┃
#                                                                              ┃
# License: Apache v2.0 (see below)                                             ┃
#                                                                              ┃
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
#                                                                              ┃
# Licensed to the Apache Software Foundation (ASF) under one more contributor  ┃
# license agreements.  See the NOTICE file distributed with this work for      ┃
# additional information regarding copyright ownership. The ASF licenses this  ┃
# file to you under the Apache License, Version 2.0 (the "License"); you may   ┃
# not use this file except in compliance with the License.                     ┃
# You may obtain a copy of the License at                                      ┃
#                                                                              ┃
#   http://www.apache.org/licenses/LICENSE-2.0                                 ┃
#                                                                              ┃
# Unless required by applicable law or agreed to in writing, software          ┃
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT    ┃
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.             ┃
# See the License for the specific language governing permissions and          ┃
# limitations under the License.                                               ┃
#                                                                              ┃
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛


# ☞ Lexer ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class LogicLexer

  require 'strscan'

  def initialize
    @rules = []
  end

  def ignore pattern
    @rules << [pattern, :SKIP]
  end

  def token pattern, token
    @rules << [pattern, token]
  end

  def keyword aString
    @rules << [Regexp.new(aString), aString]
  end

  def start aString
    @base = StringScanner.new aString
  end

  def next_token
    return [false, false] if @base.empty?
    t = get_token
    return (:SKIP == t[0]) ? next_token : t
  end

  def get_token
    @rules.each do |key, value|
      m = @base.scan(key)
      return [value, m] if m
    end
    raise  "unexpected characters  <#{@base.peek(5)}>"
  end

end

# ☞ Logic Parser ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.14
# from Racc grammer file "".
#

require 'racc/parser.rb'
class LogicParser < Racc::Parser

module_eval(<<'...end parser.y/module_eval...', 'parser.y', 24)

  def make_lexer aString
    result = LogicLexer.new
    result.ignore /\s+/
    result.keyword 'item'
    result.token /\w+/, :WORD
    result.start aString
    return result
  end


  def parse(arg)
    @result = Catalog.new
    @lexer = make_lexer arg
    do_parse
  end

# vim: set filetype=racc :
...end parser.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
     3,    12,     4,     5,     7,     8,     3,    15,     4,     5,
     3,    11,     4,     5,     3,    10,     4,     5,     7,     8,
     6,    16,     7,    17 ]

racc_action_check = [
     0,     6,     0,     0,     9,     9,     7,     9,     7,     7,
     8,     5,     8,     8,     3,     4,     3,     3,     2,     2,
     1,    11,    14,    16 ]

racc_action_pointer = [
    -7,    20,    13,     7,    13,     8,     1,    -1,     3,    -1,
   nil,    10,   nil,   nil,    17,   nil,    19,   nil ]

racc_action_default = [
    -8,    -8,    -1,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
    -5,    -6,    18,    -2,    -3,    -4,    -8,    -7 ]

racc_goto_table = [
     2,     1,   nil,     9,   nil,   nil,   nil,    13,    14 ]

racc_goto_check = [
     2,     1,   nil,     2,   nil,   nil,   nil,     2,     2 ]

racc_goto_pointer = [
   nil,     1,     0 ]

racc_goto_default = [
   nil,   nil,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 13, :_reduce_none,
  3, 14, :_reduce_2,
  3, 14, :_reduce_3,
  3, 14, :_reduce_4,
  2, 14, :_reduce_5,
  2, 14, :_reduce_6,
  4, 14, :_reduce_7 ]

racc_reduce_n = 8

racc_shift_n = 18

racc_token_table = {
  false => 0,
  :error => 1,
  :FEATURE => 2,
  :VARIABLE => 3,
  :VALUE => 4,
  "&&" => 5,
  "||" => 6,
  "(" => 7,
  ")" => 8,
  "f?" => 9,
  "v?" => 10,
  "=" => 11 }

racc_nt_base = 12

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "FEATURE",
  "VARIABLE",
  "VALUE",
  "\"&&\"",
  "\"||\"",
  "\"(\"",
  "\")\"",
  "\"f?\"",
  "\"v?\"",
  "\"=\"",
  "$start",
  "target",
  "exp" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

module_eval(<<'.,.,', 'parser.y', 13)
  def _reduce_2(val, _values, result)
     result &&= val[2]                    
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 14)
  def _reduce_3(val, _values, result)
     result ||= val[2]                    
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 15)
  def _reduce_4(val, _values, result)
     result   = val[1]                    
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 16)
  def _reduce_5(val, _values, result)
     result   = has_feature?(val[1])      
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 17)
  def _reduce_6(val, _values, result)
     result   = !get_var(val[1]).nil?     
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 18)
  def _reduce_7(val, _values, result)
     result   = get_var(val[1]) == val[3] 
    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

end   # class LogicParser

# ☞ Requires ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Core modules.
require "fileutils"
require "find"
require "ostruct"
require "net/http"
require "pathname"
require "yaml"
require "json"
require "shellwords"
require "uri"

# Try to require `thor` or raise an exception.
begin
  require "thor"
rescue
  puts "\e[31m☠ The gem `thor` is not installed. " +
       "To install run: `gem install thor`. Aborting.\e[0m"
  exit(-1)
end

# Top-level namespace.
module Fizzy
end

# ☞ Configuration ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Fizzy::CFG = OpenStruct.new

# Default editor.
Fizzy::CFG.editor = ENV["EDITOR"] || "vim"

# The operating-system which fizzy is running on.
Fizzy::CFG.os = case RUBY_PLATFORM
                when /darwin/ then :osx
                when /linux/  then :linux
                else               :windows
                end

# Remote URL for fizzy static files (must end with a slash).
Fizzy::CFG.static_files_base_url =
  URI("https://raw.githubusercontent.com/alem0lars/fizzy/master/")

# Default fizzy root directory (holding all of the fizzy stuff).
Fizzy::CFG.default_fizzy_dir = Pathname.new(
  ENV["FIZZY_DIR"] ||
  case Fizzy::CFG.os
  when :linux   then "/usr/share/fizzy"
  when :osx     then "~/Library/Application Support/fizzy"
  when :windows then "~/fizzy"
  end
).expand_path

# Default meta file name.
Fizzy::CFG.default_meta_name = "meta.yml"

# ☞ Exts → Hash ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class Hash

  # Perform recursive merge of the current `Hash` (`self`) with the provided one
  # (the `second` argument).
  #
  # The merge have knows how to recurse in both `Hash`es and `Array`s.
  #
  def deep_merge(second)
    merger = proc do |key, v1, v2|
      if Hash === v1 && Hash === v2
        v1.merge v2, &merger
      elsif Array === v1 && Array === v2
        (Set.new(v1) + Set.new(v2)).to_a
      else
        v2
      end
    end
    self.merge second, &merger
  end

  def fqkeys(prefix="")
    self.inject([]) do |acc, (k, v)|
      prefix_new = prefix.empty? ? k.to_s : "#{prefix}.#{k}"
      acc + (v.is_a?(Hash) ? v.fqkeys(prefix_new) : [prefix_new])
    end
  end

end

# ☞ Exts → Thor ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class Thor
  module Actions

    # Monkey-patch to retrieve the template currently processed.
    old_template = instance_method(:template)
    define_method :template, ->(source, *args, &blk) do
      $fizzy_cur_template = source
      old_template.bind(self).(source, *args, &blk)
    end

  end
end

# ☞ Utils → Git ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

module Fizzy::Git

  def git_info(git_root_path)
    info = nil
    FileUtils.cd(git_root_path) do
      info = {
        :local  => `git rev-parse @`.strip,
        :remote => `git rev-parse @{u}`.strip,
        :base   => `git merge-base @ @{u}`.strip
      }
    end
    info
  end

  def git_local_changes(git_root_path)
    `git status -uall --porcelain`.strip
  end

  def git_remotes
    `git remote`.split(/\W+/).reject(&:empty?)
  end

  def git_branches
    `git branch`.split(/\W+/).reject(&:empty?)
  end

  def git_has_local_changes(git_root_path)
    !git_local_changes(git_root_path).empty?
  end

  def git_should_pull(git_root_path)
    info = git_info(git_root_path)
    info[:remote] != info[:base]
  end

  def git_should_push(git_root_path)
    info = git_info(git_root_path)
    info[:local] != info[:base]
  end

  def git_pull(remote: nil, branch: nil, with_submodules: true)
    error("Invalid remote `#{remote}`.") if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") if branch && !git_branches.include?(branch)

    say "Performing pull.", :blue

    cmd  = "git pull"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    status   = exec_cmd(cmd, as_su: !existing_dir(Dir.pwd))
    status &&= exec_cmd("git submodule update --recursive",
                        as_su: !existing_dir(Dir.pwd)) if with_submodules

    status
  end

  def git_clone(url, dst_path, recursive: true)
    error("Invalid url: can't be empty.") if url.nil?
    say "Syncing from remote repo: `#{url}`.", :blue

    cmd  = "git clone"
    cmd << " --recursive" if recursive
    cmd << " #{Shellwords.escape(url)} #{Shellwords.escape(dst_path)}"

    exec_cmd(cmd, :as_su => !existing_dir(File.dirname(dst_path)))
  end

  def git_push(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`.") if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") if branch && !git_branches.include?(branch)

    say "Pushing to remote.", :blue

    cmd  = "git push"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    exec_cmd(cmd, as_su: !existing_dir(Dir.pwd))
  end

  def git_fetch(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`.") if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") if branch && !git_branches.include?(branch)

    say "Fetching from remote.", :blue

    cmd  = "git fetch"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    exec_cmd(cmd, as_su: !existing_dir(Dir.pwd))
  end

  def git_add(files: nil)
    error("Invalid files `#{files}`.") unless files.nil? || files.is_a?(Array)

    cmd  = "git add"
    if files.nil?
      cmd << " -A"
    else
      cmd << files.map { |f| Shellwords.escape(f) }.join(" ")
    end

    exec_cmd(cmd, as_su: !existing_dir(Dir.pwd))
  end

  def git_commit(message: nil)
    say "Performing commit.", :blue

    cmd = "git commit -a"
    if message.nil?
      cmd << " --allow-empty-message"
    else
      cmd << " -m #{Shellwords.escape(message)}"
    end

    exec_cmd(cmd, as_su: !existing_dir(Dir.pwd))
  end

end

# ☞ Utils → Environment ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Utilities to retrieve informations about the host environment & system.
#
module Fizzy::Environment

  # Return the environment variable matching the provided `name`.
  #
  def get_env(name, default: nil)
    ENV[name.to_s] || default
  end

  # Same of `get_env`, but raise an error if the environment variable hasn't
  # been found or is `nil`.
  #
  def get_env!(name)
    get_env(name) || error("Undefined environment variable: `#{name}`.")
  end

  # Check if the underlying operating system is MacOSX.
  #
  def is_osx?
    Fizzy::CFG.os == :osx
  end

  # Check if the underlying operating system is GNU/Linux.
  #
  def is_linux?
    Fizzy::CFG.os == :linux
  end

end

# ☞ Utils → Execution ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Utilities to start and manage programs execution.
#
module Fizzy::Execution

  # Execute the provided shell command (`cmd`).
  #
  # If `as_su` is `true` the command is executed as super user (i.e. as root,
  # using sudo).
  #
  def exec_cmd(cmd, as_su: false)
    full_cmd = as_su ? "sudo #{cmd}" : cmd

    really_run = case @run_mode
                 when :normal
                   true
                 when :paranoid
                   quiz("Do you want to run command `#{full_cmd}`")
                 when :dry
                   false
                 else
                   true
                 end

    if really_run || @run_mode == :dry
      say as_su ? "[sudo] #{cmd}" : cmd, :magenta
    end

    if really_run
      system(full_cmd) || warning("Command `#{full_cmd}` failed.")
    end
  end

end

# ☞ Utils → Meta Info ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Access informations declared in the meta file.
#
module Fizzy::MetaInfo

  # Return the normalized and validated meta object.
  #
  # Be sure to call `setup_vars` before calling this method.
  #
  def get_meta(meta_path, vars_path, elems_base_path, verbose) # {{{
    say 'Getting meta informations.', :blue

    meta = YAML.load(File.read(meta_path))
    meta["all_elems_count"] = meta['elems'].count

    # Step 1: Normalize elements ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    elem_erb_excluded_fields = ['only']

    meta['elems'] = [] unless meta.has_key? 'elems'

    meta['elems'] = meta['elems'].each_with_index.collect do |elem, idx|
      elem_identifier = elem['name'] || "src = #{elem['src']}"
      info("\nElement: ", elem_identifier) if verbose

      # Step 1.1: Validate `only` and determine if the element is selected.
      if elem.has_key?('only') && !elem['only'].is_a?(Hash)
        error "The configuration element `#{elem_identifier}` has invalid " +
              "`only`: it's not a `Hash`."
      end
      selected = selected_by_only?(elem['only'], verbose)

      # Step 1.2: Pre-process strings with ERB.
      if selected
        elem.each do |k, v|
          unless elem_erb_excluded_fields.include? k
            elem[k] = ERB.new(v).result(binding)
          end
        end
      end

      # Step 1.3: Validate and normalize `name`, `src`, `dst`, `fs_maps`.
      if selected
        unless elem.has_key?('src')
          error "Element `#{elem_identifier}` doesn't contain `src`."
        end
        unless elem.has_key?('name')
          elem['name'] = elem['src']
        end
        unless elem.has_key?('dst')
          error "Element `#{elem_identifier}` doesn't contain `dst`."
        end
        elem['fs_maps'] = []
      end

      selected ? elem : nil
    end.compact

    # Step 1.4: For each active elem, match the `src` field against the
    #           filesystem and determine filesystem mapping (`fs_maps`).
    meta['elems'].each do |elem|
      found = false

      Find.find(elems_base_path).select {|ebp| File.file? ebp }
          .each do |subfile_path|
        subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
          Pathname.new(elems_base_path)).to_s
        if md = Regexp.new(elem['src']).match(subfile_rel_path.gsub(/\.tt$/, ''))
          found = true
          dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
            idx = Integer($1)
            unless (1..md.length) === idx
              error "Invalid 'dst' for element `#{elem['name']}`: nothing " +
                    "captured at index `#{idx}`."
            else
              md[idx]
            end
          end
          elem['fs_maps'] << {
            'src_path' => File.expand_path(subfile_path),
            'dst_path' => File.expand_path(dst_path)
          }
        end
      end

      unless found
        warning "Inconsistency found for elem `#{elem['name']}`: no file " +
                "matches src: `#{elem['src']}`."
      end
    end

    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    # Step 2: Normalize commands ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    command_excluded_erb_fields = ['only']

    meta['commands'] = [] unless meta.has_key? 'commands'

    meta['commands'] = meta['commands'].each_with_index.collect do |spec, idx|
      spec['name'] ||= "type = #{spec['type']}, index = #{idx}"
      info("\nCommand: ", spec['name']) if verbose

      # Step 2.1: Validate 'only' and determine if the command is selected.
      if spec.has_key?('only') && !spec['only'].is_a?(Hash)
        error "The command `#{spec['name']}` has invalid `only`: it's not " \
              'a `Hash`.'
      end
      selected = selected_by_only?(spec['only'], verbose)

      if selected

        # Step 2.2: Pre-process strings with ERB.
        spec.each do |key, value|
          unless command_excluded_erb_fields.include? key
            spec[key] = ERB.new(value).result(binding)
          end
        end

        # Step 2.3: Validate `type`, `validator`, `executor`.
        if !spec.has_key?('type') ||
           !available_commands.keys.include?(spec['type'])
          error "The command `#{spec['name']}` has invalid `type`: it's " \
                "not in `#{available_commands.keys}`."
        end
        command = available_commands[spec['type']]
        if command.has_key?('validator') && !command['validator'].is_a?(Proc)
          error "Invalid validator for command `#{spec['name']}`: if " \
                "provided it should be a `Proc`."
        end
        if !command.has_key?('executor') || !command['executor'].is_a?(Proc)
          error "Invalid executor for command `#{spec['name']}`: it should " \
                'be a `Proc`.'
        end

        # Step 2.4: Use type-specific validator if it's defined.
        if command.has_key?('validator') && (
             !command['validator'].is_a?(Proc) ||
             !command['validator'].call(spec)
           )
          error "The validator for command `#{spec['name']}` didn't pass."
        end
      end

      selected ? spec : nil
    end.compact

    # ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

    # Build the list of excluded files (needed by Thor's `directory()`).
    all_files = Set.new Find.find(elems_base_path).select { |f| File.file? f }
    src_paths = Set.new(
      meta['elems'].collect_concat do |elem|
        elem['fs_maps'].collect { |m| m['src_path'] }
      end
    )
    vars_files = Dir.glob(File.join(vars_path, '*'), File::FNM_DOTMATCH)
    meta['system_files'] = Set.new(vars_files << meta_path)
    meta['excluded_files'] = all_files - src_paths - meta['system_files']
    meta['all_files_count'] = all_files.count

    meta
  end # }}}

  # Return whether the provided `only` specification is evaluated as an allows
  # and not as a denies.
  #
  def selected_by_only?(only, verbose)
    unless only
      selected = true
      info(' ↳ ', "#{set_color('✔', :green)} (`only` is empty).") if verbose
    else
      wants_features = only.has_key?('features')
      wants_vars     = only.has_key?('vars')

      feat_ok = if wants_features
                  only['features'].any? do |feature|
                    case feature
                    when Array
                      feature.all? { |f| has_feature? f }
                    else
                      has_feature? feature
                    end
                  end
                else
                  true
                end
      vars_ok = wants_vars ?
          only['vars'].any? { |var| !get_var(var).nil? } :
          true

      selected   = !wants_features && !wants_vars
      selected ||= (feat_ok && vars_ok)

      if selected && verbose
        info ' ↳ ', "#{set_color('✔', :green)} (`only` is present and " +
                    'satisfied).'
      end
    end

    if !selected && verbose
      info ' ↳ ', "#{set_color('✘', :red)} (`only` is present and didn't " +
                  'match).'
    end

    selected
  end

end

# ☞ Utils → Meta Elements ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Manage elements declared in the meta file.
#
module Fizzy::MetaElements

  # Return a list of functions capable to apply modifications on the system
  # based on the current elements configuration instance.
  #
  # In particular, an applier work for each element installed.
  #
  def elements_appliers
    [ lambda { |elem| # Create parent directories.
        elem["fs_maps"].each do |m|
          parent_dir = File.dirname(m["dst_path"])
          if elem.has_key?("perms")
            l_ex_dir_path = f_noex_dir_path = parent_dir
            while !File.directory?(l_ex_dir_path)
              f_noex_dir_path = l_ex_dir_path
              l_ex_dir_path   = File.dirname(l_ex_dir_path)
            end
          else
            l_ex_dir_path = f_noex_dir_path = nil
          end
          # From here, we have the following variable set:
          # - `l_ex_dir_path`: Longest path prefix which points to an existing
          #                    directory.
          # - `f_noex_dir_path`: Path of the first directory after the prefix
          #                      which points to an existing dir.
          if !File.directory?(parent_dir)
            exec_cmd("mkdir -p #{Shellwords.escape(parent_dir)}",
                     as_su: !existing_dir(parent_dir))
          end
        end
      },
      lambda { |elem| # Create a symlink for each elements' `src_path`.
        elem["fs_maps"].each do |m|
          say "  #{m["src_path"]} ← #{m["dst_path"]}" if @verbose
          cmd = "ln -s"
          should_link = if File.file?(m["dst_path"])
            dst_real_path = Pathname.new(m["dst_path"]).realpath.to_s
            if dst_real_path != m["src_path"]
              cmd << " -f"
              quiz "The destination file `#{m["dst_path"]}` already " +
                   "exists. Overwrite"
            else
              false
            end
          elsif File.directory?(m["dst_path"])
            if quiz "The destination file `#{m["dst_path"]}` is a " +
                    "directory. Delete it"
              exec_cmd("rm -Rf #{m["dst_path"]}",
                       as_su: !existing_dir(File.dirname(m["dst_path"])))
            end
          else
            # Link does not exist yet.
            true
          end

          if should_link
            cmd << " \"#{m["src_path"]}\" \"#{m["dst_path"]}\""
            exec_cmd(cmd,
                     :as_su => !existing_dir(File.dirname(m['dst_path'])))
          end
        end
      },
      lambda { |elem| # Change permissions of the instantiated files (if specified).
        if elem.has_key?("perms")
          elem["fs_maps"].each do |m|
            say "Changing permissions of #{m['src_path']} to #{elem["perms"]}" if @verbose
            exec_cmd("chmod -R #{Shellwords.escape(elem["perms"])} #{Shellwords.escape(m["src_path"])}",
                     as_su: !File.owned?(m["src_path"]))
          end
        end
      }
    ]
  end

end

# ☞ Utils → Meta Commands ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Manage commands declared in the meta file.
#
module Fizzy::MetaCommands

  # Return a data structure containing the commands that can be specified in
  # the meta file.
  #
  # The data structure defines:
  # - The available command types (`available_commands.keys`).
  # - (Optionally) A validator that can be used to validate type-specific
  #   validation rules.
  # - The command executor: A `Lambda` containing the code used for executing
  #   that command.
  #
  def available_commands
    { "git_sync" => {
        "validator" => lambda { |spec|
          if spec.has_key?("dst")
            spec["dst"] = File.expand_path(spec["dst"])
          end
          status   = spec.has_key?("repo")
          status &&= spec.has_key?("dst")
        },
        "executor" => lambda { |spec|
          if File.directory?(spec["dst"])
            FileUtils.cd(spec["dst"]) { git_pull }
          else
            git_clone(spec["repo"], spec["dst"])
          end
        }
      }
    }
  end
end

# ☞ Utils → Vars ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

module Fizzy::Vars

  attr_reader :vars

  # Setup the variables that will be used during ERB processing.
  #
  # Those variables will be set into an instance field called `@vars`.
  #
  # After calling this method, you can directly access the variables using
  # `@vars` or using the attribute reader `vars`.
  #
  def setup_vars(vars_dir_path, name)
    info "vars: ", name
    @vars = _setup_vars(vars_dir_path, name)
  end

  # Check if the feature with the provided name (`feature_name`) is enabled.
  #
  # Since the features are defined just using variables, before calling this
  # method be sure that `setup_vars` has already been called.
  #
  def has_feature?(feature_name)
    get_var!('features').include? feature_name.to_s
  end

  # Filter the values associated to the features, keeping only those
  # associated to available features.
  #
  def data_for_features(info, sep: nil)
    data = []
    info.each do |feature_name, associated_value|
      if has_feature?(feature_name.to_sym)
        if associated_value.respond_to?(:call)
          data << associated_value.call
        else
          data << associated_value
        end
      end
    end
    if data.length == 1
      def data.inspect
        first
      end
    elsif sep
      def data.inspect
        join sep
      end
    end
    data
  end

  # Same of `get_var`, but raise an error if the variable hasn't been found or
  # is `nil`.
  #
  def get_var!(var_name, type: nil)
    value = get_var(var_name, type: type)
    error("Undefined variable: `#{var_name}`.") if value.nil?
    value
  end

  # Return the variable matching the provided `name`.
  #
  # The variables object being looked up is the one returned from the
  # method `vars`.
  #
  def get_var(var_name, type: nil, strict: false)
    _typize_var(var_name, _get_var(vars, var_name), type, strict)
  end

  def _typize_var(var_name, var, type, strict)
    return var if type.nil? || type.end_with?("?") && var.nil?
    case type
    when :string, :str
      strict ? _ensure_type!(var_name, var, String) : var.to_s
    when :symbol, :sym
      strict ? _ensure_type!(var_name, var, Symbol) : var.to_s.to_sym
    when :integer
      strict ? _ensure_type!(var_name, var, Integer) : Integer(var)
    when :boolean, :bool
      if strict
        _ensure_type!(var_name, var, TrueClass, FalseClass)
      else
        if var.nil?
          nil
        elsif var.is_a?(TrueClass) || var.to_s == "true"
          true
        elsif var.is_a?(FalseClass) || var.to_s == "false"
          false
        else
          error "Invalid value `#{var}` for variable `#{var_name}`: " +
                "it can't be converted to a boolean."
        end
      end
    when :path, :pth then
      if strict && !File.exist?(var)
        error "Invalid variable `#{var_name}`: `#{var}` doesn't exist"
      else
        Pathname.new var
      end
    when :file, :pth then
      if strict && !File.file?(var)
        error "Invalid variable `#{var_name}`: `#{var}` isn't a file"
      else
        Pathname.new var
      end
    when :directory, :dir then
      if strict && !File.directory?(var)
        error "Invalid variable `#{var_name}`: `#{var}` isn't a directory"
      else
        Pathname.new var
      end
    else
      error "Unhandled type `#{type}`. " +
            "If you need support for a new type, open an issue."
    end
  end

  def _ensure_type!(var_name, var, *types)
    if types.any? { |type| var.is_a? type }
      var
    else
      error "Invalid type for variable: `#{var_name}`: " +
            "it's not a `#{type.name}`."
    end
  end

  def _get_var(vars, var_name)
    dot_split_regexp = /([^.]+)(?:\.|$)/
    var_name.to_s
      .scan(dot_split_regexp).map { |match_group| match_group[0] }
      .reject(&:empty?)
      .inject(vars) do |cur_obj, name_component|

      nxt_obj = if cur_obj.has_key?(name_component)
        cur_obj[name_component]
      else
        nil
      end
      nxt_obj or break nil
    end
  end

  def _read_vars(vars_dir_path, name)
    yaml_file_path = find_yaml_path(File.join(vars_dir_path, name))
    if yaml_file_path
      [:yaml, File.read(yaml_file_path)]
    elsif ENV.has_key? name
      [:json, ENV[name]]
    else
      [nil, nil]
    end
  end

  def _parse_parents_vars(fmt, content)
    dummy_regex = /none|nothing/i
    parents_regex = case fmt
    when :yaml then /^#\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*#\s*/
    when :json then /^\/\*\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*\*\/\s*/
    else error("Unrecognized format: `#{fmt}`")
    end
    if md = content.match(parents_regex)
      md[:parents].split(",").map(&:strip).reject { |p| p =~ dummy_regex }
    else
      []
    end
  end

  def _parse_vars(fmt, content)
    case fmt
    when :yaml then YAML.load(content) || {}
    when :json
      begin
        JSON.parse(content)
      rescue
        error("Invalid JSON: `#{content}`.")
      end
    else error("Unrecognized format: `#{fmt}`")
    end
  end

  def _merge_with_parents_vars(self_vars, parents_vars)
    parents_vars.deep_merge(self_vars)
  end

  def _get_vars_collisions(parents_vars)
    collisions = []
    parents_vars.each do |parent_vars|
      parent_vars_keys = parent_vars.fqkeys
      others_vars = parents_vars - [parent_vars]
      others_vars.each do |other_vars|
        other_vars_keys = other_vars.fqkeys
        common_keys = other_vars_keys & parent_vars_keys
        common_keys.each do |key|
          value_a = _get_var(parent_vars, key)
          value_b = _get_var(other_vars, key)
          if value_a != value_b
            collisions << { key: key, value_a: value_a, value_b: value_b }
          end
        end
      end
    end
    collisions.uniq do |c| # Remove duplicate collisions.
      [c[:key]] + [c[:value_a], c[:value_b]].sort
    end
  end

  def _merge_parents_vars(vars_dir_path, parents)
    parents.inject([]) do |acc, parent| # Vars for each parent.
      parent_vars = _setup_vars(vars_dir_path, parent)
      acc << parent_vars
      collisions = _get_vars_collisions(acc)
      unless collisions.empty?
        error "Inconsistent variables specification:\n" + collisions.map { |c|
          "\t→ Collision with key=`#{c[:key]}`: value_a=`#{c[:value_a]}` value_b=`#{c[:value_b]}`"
        }.join("\n")
      end
      acc
    end.inject({}) do |acc, parent_vars| # Merge them.
      acc.deep_merge(parent_vars)
    end
  end

  def _setup_vars(vars_dir_path, name)
    fmt, content = _read_vars(vars_dir_path, name)
    error("Invalid vars: `#{name}`.") if fmt == nil || content == nil
    self_vars = _parse_vars(fmt, content)
    parents = _parse_parents_vars(fmt, content)
    parents_vars = _merge_parents_vars(vars_dir_path, parents)
    _merge_with_parents_vars(self_vars, parents_vars)
  end

end

# ☞ Utils → Locals ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

module Fizzy::Requirements

  class Proxy

    attr_reader :locals

    def initialize(receiver)
      @receiver = receiver
      @locals   = {}
    end

    # Create a new `local` fetching the value from the corresponding `variable`.
    #
    def variable(name, *args, **kwargs)
      name = name.to_s.to_sym
      error "Invalid local name `#{name}`: it's blank." if name.empty?
      type = options.fetch :type, nil
      local_name = options.fetch :as, name
      if optional
        @locals[local_name] = receiver.get_var name, type: type
      else
        @locals[local_name] = receiver.get_var! name, type: type
      end
    end

    # Create a new computed `local`, based upon other locals.
    #
    def computed(name, fn)
      name = name.to_s.to_sym
      error "Invalid local name `#{name}`: it's blank." if name.empty?
      error("Cannot compute local `#{name}`.") if fn.nil?

      @locals[name] = fn.call
    end

    # Access the value of a local.
    #
    def local(name)
      locals[name]
    end

    # Access the value of a local or raise an error if it's not defined.
    #
    def local!(name)
      value = local(name)
      error("Undefined local `#{name}`.") if value.nil?
      value
    end

    def local?(*names, &block)
      values = names.collect { |name| local(name) }
      are_locals_available = values.compact.length != values.length
      yield(*values) if are_locals_available
    end

  end

  def define_locals(&block)
    error("No requirements specification provided.") unless block_given?
    proxy = Fizzy::Requirements::Proxy.new self
    proxy.instance_eval(&block)
    self.locals = proxy.locals
  end

end

# ☞ Utils → Filesystem ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Utilities to interact with the filesystem.
#
module Fizzy::Filesystem

  # Find a YAML file prefixed by `path` (guess extension name).
  #
  def find_yaml_path(path)
    if File.file?(path)
      path
    else
      %w(yml yaml).map do |ext|
        "#{path}.#{ext}" if File.file? "#{path}.#{ext}"
      end.compact.first
    end
  end

  # Check if the provided `path` is an existing directory.
  #
  # If `writable` is true, also check if `path` points to a writable
  # directory.
  #
  def existing_dir(path, writable: true)
    dir_path = path
    dir_path = File.dirname(dir_path) until File.directory?(dir_path)
    (writable && !File.writable?(dir_path)) ? nil : dir_path
  end

  # Return an object (`OpenStruct`), which contains all of the well-known
  # paths.
  #
  # Before adding a path, some validations are executed to ensure that path
  # points to a correct thing.
  #
  # You can skip some validations and filling some paths:
  # - `valid_cfg`: If `false` don't validate and fill paths related to the
  #                configuration.
  # - `valid_inst`:
  #   - If `false` don't validate and fill paths related to the configuration
  #     instances.
  #   - If `true`, be sure to provide the argument `cur_inst_name`, which
  #     should contain the name of the current instance (the instance that
  #     should be used).
  #
  def prepare_storage(root_path,
                      valid_meta: true, valid_cfg: true, valid_inst: true,
                      meta_name: nil, cur_cfg_name: nil, cur_inst_name: nil)
    root_path = Pathname.new(root_path).expand_path

    # Paths based on internal conventions.
    parent_path = root_path.dirname

    cfg_path = root_path.join("cfg")
    cur_cfg_path = cfg_path.join(cur_cfg_name) if cur_cfg_name
    cur_cfg_vars_path = cur_cfg_path.join("vars") if cur_cfg_path
    cur_cfg_meta_path = find_yaml_path(cur_cfg_path.join(meta_name)) if cur_cfg_path && meta_name

    inst_path = root_path.join("inst")
    cur_inst_path = inst_path.join(cur_inst_name) if cur_inst_name
    cur_inst_vars_path = cur_inst_path.join("vars") if cur_inst_path
    cur_inst_meta_path = find_yaml_path(cur_inst_path.join(meta_name)) if cur_inst_path && meta_name

    # Validate `root_path`.
    if !File.directory?(root_path) && !File.writable?(parent_path)
      error "Cannot create directory: `#{root_path}`."
    end
    if File.file?(root_path)
      if quiz "`#{root_path}` already exists but is a regular file. Remove?"
        exec_cmd "rm #{Shellwords.escape(root_path)}",
                 as_su: File.owned?(root_path)
      else
        error "File `#{root_path}` already exists but is needed as fizzy " +
              "root directory. Aborting."
      end
    end
    if !valid_cfg && File.directory?(root_path) && !File.writable?(root_path)
      error "No write permissions in Fizzy storage at path `#{root_path}`."
    end

    if valid_cfg
      unless File.directory?(root_path)
        error "The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`)."
      end
      if !File.directory?(cur_cfg_path) || !File.writable?(cur_cfg_path)
        error "The current configuration `#{cur_cfg_name}` is invalid: " +
              "it's not a valid directory."
      end
      if valid_meta && !File.file?(cur_cfg_meta_path)
        error "The meta file path `#{cur_cfg_meta_path}` is invalid."
      end
      unless File.directory?(cur_cfg_vars_path)
        error "The variables directory `#{cur_cfg_vars_path}` is invalid."
      end
    end

    if valid_inst
      unless root_path.directory?
        error "The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`)."
      end
      if !cur_inst_path.directory? || !cur_inst_path.writable?
        error "The current instance `#{cur_inst_name}` is invalid: it's " +
              "not a valid directory."
      end
      if valid_meta && !cur_inst_meta_path.file?
        error "The meta file path `#{cur_inst_meta_path}` is invalid."
      end
      unless cur_inst_vars_path.directory?
        error "The variables directory `#{cur_inst_vars_path}` is invalid."
      end
    end

    # Create non-existing internal directories.
    FileUtils.mkdir_p(root_path) unless root_path.directory?
    [cfg_path, inst_path].each do |dir_path|
      unless dir_path.directory?
        FileUtils.mkdir_p(dir_path)
        exec_cmd "chmod a+w #{Shellwords.escape(dir_path)}",
                 as_su: File.owned?(dir_path)
      end
    end
    if cur_inst_path && !cur_inst_path.directory?
      FileUtils.mkdir_p(cur_inst_path)
    end

    # Return the known storage paths.
    OpenStruct.new(
      root:          root_path,
      cfg:           cfg_path,
      cur_cfg:       cur_cfg_path,
      cur_cfg_vars:  cur_cfg_vars_path,
      cur_cfg_meta:  cur_cfg_meta_path,
      inst:          inst_path,
      cur_inst:      cur_inst_path,
      cur_inst_vars: cur_inst_vars_path,
      cur_inst_meta: cur_inst_meta_path)
  end

end

# ☞ Utils → Io ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

module Fizzy::IO

  # Ask a question to the user.
  #
  # The message is made by the `question` string, with some additions (like
  # `?` sign).
  #
  # The available quiz types are:
  # - `:bool`: Boolean quiz, the user can respond with `yes` or `no` (or
  #            alternatives, see regexes below). A boolean value is returned.
  # - `:string`: Normal quiz, the user is prompt for a question and if the
  #              answer isn't empty is returned.
  #
  def quiz(question, type: :bool)
    answer = ask "#{question.strip}? ", :magenta
    case type
    when :bool
      if answer =~ /y|ye|yes|yeah|ofc/i
        true
      elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
        false
      else
        say "Answer misunderstood", :yellow
        quiz question, type: type
      end
    when :string
      if answer.empty?
        warning "Empty answer", ask_continue: false
        quiz question, type: type
      else
        answer
      end
    else
      error "Unhandled question type: `#{type}`."
    end
  end

  # Display an informative message (`msg`) to the user.
  #
  # The `prefix` argument should contain some text displayed before the
  # message, typically to show the context which the message belongs to.
  #
  def info(prefix, msg)
    say "☞ #{set_color(prefix, :cyan)}#{set_color(msg, :white)}"
  end

  # Display an informative message (`msg`) to the user.
  #
  # If `ask_continue` is `true`, the user can interactively choose to stop
  # the program or exit (with exit status `-1`).
  #
  def warning(msg, ask_continue: true)
    say "⚠ #{msg}", :yellow
    exit(-1) if ask_continue && !quiz("continue")
  end

  # Display an error message (`msg`) to the user. Before returning, the
  # program will exit (with exit status `-1`).
  #
  def error(msg)
    say "☠ #{msg}", :red
    exit(-1)
  end

end

# ☞ Commands → Base ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Base class for all fizzy commands.
#
class Fizzy::BaseCommand < Thor

  include Thor::Actions

  include Fizzy::Environment
  include Fizzy::Execution
  include Fizzy::Filesystem
  include Fizzy::Git
  include Fizzy::IO
  include Fizzy::MetaInfo
  include Fizzy::MetaElements
  include Fizzy::MetaCommands
  include Fizzy::Vars
  include Fizzy::Requirements

  # Common options, shared among many commands.
  #
  SHARED_OPTIONS = {
    verbose: {
      default: false,
      type:    :boolean,
      aliases: :verb,
      desc:    "Whether the output should be verbose."
    },
    run_mode: {
      default: "normal",
      aliases: [:rm, :r],
      enum:    %w(normal paranoid dry),
      desc:    "Ask confirmation for each filesystem operation."
    },
    fizzy_dir: {
      default: Fizzy::CFG.default_fizzy_dir,
      aliases: :f,
      desc:    "The root path for the directory internally used by fizzy."
    },
    cfg_url: {
      default: nil,
      aliases: [:cu],
      desc: "The URL to the repository holding config."
    },
    cfg_name: {
      default: nil,
      aliases: [:cfg, :c],
      desc:    "The name of the configuration that should be used."
    },
    inst_name: {
      default: nil,
      aliases: [:inst, :i],
      desc:    "The name for the configuration instance to be used."
    },
    vars_name: {
      default: nil,
      aliases: [:vars, :v],
      desc:    "The name for the variables file to be used."
    },
    meta_name: {
      default: Fizzy::CFG.default_meta_name,
      aliases: [:meta, :m],
      desc:    "The name of the meta file."
    }
  }

  class << self

    include Fizzy::IO

    # Get a shared option.
    #
    def shared_option(name, required: false)
      args = SHARED_OPTIONS[name].dup
      error "Invalid option `#{name}`: it doesn't exist." if args.nil?

      if required
        args.delete :default
        args[:required] = true
      elsif !args.has_key? :default
        error "Invalid shared option `#{name}`: doesn't have a default value."
      end

      [name, args]
    end

  end

end

# ☞ Commands → Cfg ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class Fizzy::CfgCommand < Fizzy::BaseCommand

  def self.source_root
    "/"
  end

  method_option(*shared_option(:fizzy_dir))
  desc "cleanup",
       "Cleanup the fizzy storage."
  def cleanup
    # Prepare paths for cleanup.
    paths = prepare_storage options.fizzy_dir,
                            valid_meta: false,
                            valid_cfg:  false,
                            valid_inst: false

    # Perform cleanup.
    status = exec_cmd "rm -Rf #{Shellwords.escape(paths.root)}" \
      if quiz "Do you want to remove the fizzy root directory `#{paths.root}`"

    # Inform user about the cleanup status.
    if status
      say "Successfully cleaned: `#{paths.root}`.", :green
    elsif status.nil?
      warning "Cleanup skipped.", ask_continue: false
    else
      error "Failed to cleanup: `#{paths.root}`.", :red
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc "cd",
       "Change directory to the configuration directory " +
       "(useful for extensive filesystem manipulations)."
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            valid_cfg:    !options.cfg_name.nil?,
                            cur_cfg_name: options.cfg_name

    # Changing directory.
    dir_path = paths.cur_cfg || paths.cfg
    say "Changing directory to: `#{dir_path}`.", :cyan
    FileUtils.cd dir_path
    system get_env! :SHELL

    # Inform user about the changing directory status.
    say "CD done in: `#{dir_path}`.", :green
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc "edit PATTERN",
       "Find the files relative to PATTERN and edit them."
  def edit(pattern)
    # Prepare stuff for editing.
    paths = prepare_storage options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name
    find_path = (paths.cur_cfg || paths.cfg).join pattern
    cfg_files_arg = if find_path.exist?
                      Shellwords.escape find_path
                    else
                      Dir.glob("#{find_path}*", File::FNM_DOTMATCH).to_a.
                        delete_if { |path| path =~ /\.git/ }.
                        collect   { |path| Shellwords.escape(path) }.
                        join " "
                    end.strip

    # Perform edit.
    if cfg_files_arg.empty?
      warning "No files matching `#{cfg_name}` have been found.",
              ask_continue: false
      status = nil
    else
      say "Editing configuration file(s): `#{cfg_files_arg}`.", :cyan
      status = system "#{Fizzy::CFG.editor} #{cfg_files_arg}"
    end

    # Inform user about the editing status.
    if status
      say "Successfully edited: `#{cfg_files_arg}`.", :green
    elsif status.nil?
      warning "Editing skipped.", ask_continue: false
    else
      error "Failed to edit: `#{cfg_files_arg}`.", :red
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  method_option(*shared_option(:cfg_url))
  desc "sync", "Synchronize the remote repository with the local one."
  def sync
    # Prepare stuff for syncing.
    paths = prepare_storage options.fizzy_dir,
                            valid_meta:   false,
                            valid_cfg:    false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name

    # Perform sync.
    sync_result = if paths.cur_cfg.directory?
      say "Syncing from origin", :blue
      status = nil
      FileUtils.cd(paths.cur_cfg) do
        # Perform fetch, because we need to know if there are remote changes,
        # so we need to know the updated remote commit hash.
        say "Fetching informations from origin.", :cyan
        status = git_fetch
        # (Optional) Perform commit.
        if status && git_has_local_changes(paths.cur_cfg)
          say "The configuration has the following local changes:\n" +
              "#{set_color(git_local_changes(paths.cur_cfg), :white)}", :cyan
          should_commit = quiz "Do you want to commit them all"
          if should_commit
            commit_msg = quiz "Type the commit message", type: :string
            status   = git_add
            status &&= git_commit message: commit_msg
          else
            status = false
          end
        end
        # (Optional) Perform pull.
        status = git_pull if status && git_should_pull(paths.cur_cfg)
        # (Optional) Perform push.
        status = git_push if status && git_should_push(paths.cur_cfg)
      end
      status
    else
      git_clone options.cfg_url, paths.cur_cfg
    end

    # Inform user about sync status.
    if sync_result
      say "Synced to: `#{paths.cur_cfg}`.", :green
    else
      error "Unable to sync."
    end
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name, required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc "instantiate",
       "Create a configuration instance in the current machine."
  def instantiate
    # Before instantiation.
    paths = prepare_storage options.fizzy_dir,
                            meta_name:     options.meta_name,
                            valid_inst:    false,
                            cur_cfg_name:  options.cfg_name,
                            cur_inst_name: options.inst_name
    setup_vars paths.cur_cfg_vars, options.vars_name

    meta = get_meta paths.cur_cfg_meta, paths.cur_cfg_vars, paths.cur_cfg,
                    options.verbose

    info "meta: ", "#{set_color(meta["elems"].count, :green)}/" +
                   "#{meta["all_elems_count"]} elem(s) selected."
    info "meta: ", "#{set_color(meta["excluded_files"].count, :red)}/" +
                   "#{meta["all_files.count"]} file(s) excluded."
    say

    # Create a configuration instance.
    say "Creating a configuration instance named `#{options.inst_name}` " +
        "from: `#{paths.cur_cfg}`.", :blue

    exclude_pattern = /\.git|README/
    meta["excluded_files"].each do |excluded_file|
      exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
    end

    begin
      directory paths.cur_cfg, paths.cur_inst, exclude_pattern: exclude_pattern
    rescue SyntaxError
      error "Error while processing the template: `#{$fizzy_cur_template}`."
    end

    # After instantiation.
    say "Created the configuration instance in: `#{paths.cur_inst}`.", :green
  end

end

# ☞ Commands → Inst ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class Fizzy::InstCommand < Fizzy::BaseCommand

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name))
  desc "cd",
       "Change directory to the instance directory " +
       "(useful for extensive filesystem manipulations)."
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage options.fizzy_dir,
                            valid_meta:    false,
                            valid_cfg:     false,
                            valid_inst:    !options.inst_name.nil?,
                            cur_inst_name: options.inst_name

    # Changing directory.
    dir_path = paths.cur_inst || paths.inst
    say "Changing directory to: `#{dir_path}`.", :cyan
    FileUtils.cd dir_path
    system get_env! :SHELL

    # Inform user about the changing directory status.
    say "CD done in: `#{dir_path}`.", :green
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc "install",
       "Install the current configuration instance in the system."
  def install
    # Prepare stuff for performing install.
    @run_mode = options.run_mode.to_sym
    @verbose = options.verbose
    paths = prepare_storage options.fizzy_dir,
                            valid_cfg:     false,
                            meta_name:     options.meta_name,
                            cur_inst_name: options.inst_name
    setup_vars paths.cur_inst_vars, options.vars_name

    meta = get_meta paths.cur_inst_meta, paths.cur_inst_vars, paths.cur_inst,
                    options.verbose

    # Install the instance into the system.
    say "Installing the configuration instance `#{options.inst_name}` " +
        "into the system.", :blue

    meta["elems"].each do |elem|
      say "Installing element: `#{elem["name"]}`.", :cyan
      elements_appliers.each { |applier| applier.call(elem) }
      if elem["notes"]
        say "Notes for `#{elem["name"]}`:", :yellow
        say elem["notes"].split("\n").collect { |s| "  #{s}" }.join("\n")
      end
    end
    meta["commands"].each do |spec|
      say "Executing command: `#{spec["name"]}`.", :cyan
      available_commands[spec["type"]]["executor"].call spec
    end

    # Inform the user about installation status.
    say "The configuration instance `#{options.inst_name}` has been " +
        "installed into the system", :green
  end

end

# ☞ Commands → Main ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

class Fizzy::MainCommand < Fizzy::BaseCommand

  desc "cfg SUBCOMMAND ...ARGS",
       "Manage the Fizzy configuration (without modifying the host system)."
  subcommand "cfg", Fizzy::CfgCommand

  desc "inst SUBCOMMAND ...ARGS",
       "Manage a configuration instance"
  subcommand "inst", Fizzy::InstCommand

  desc "usage",
       "Show how to use Fizzy."
  def usage
    url = URI.join Fizzy::CFG.static_files_base_url, "README.md"
    res = Net::HTTP.get_response url
    if res.is_a? Net::HTTPSuccess
      say "\n#{res.body}\n"
    else
      error "Network error: cannot retrieve `#{url}`."
    end
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name, required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc "quick-install",
       "Quickly install a configuration."
  def quick_install
    invoke CfgCommand, "instantiate", [],
           cfg_name:  options.cfg_name,
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           verbose:   options.verbose
    invoke InstCommand, "install", [],
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           run_mode:  options.run_mode,
           verbose:   options.verbose
  end
  map :qi => :quick_install

end

# ☞ Main ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

# Entry point.
Fizzy::MainCommand.start ARGV

#!/usr/bin/env ruby

# File header ─────────────────────────────────────────────────────────────────┐
#                                                                              │
# File informations:                                                           │
# - Name:    fizzy                                                             │
# - Summary: The hassle free configuration manager                             │
# - Authors:                                                                   │
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)              │
# - Contributors:                                                              │
#   - Luca Molari <molari.luca@gmail.com> (lmolr)                              │
#   Special thanks:                                                            │
#   - Thor project (https://github.com/erikhuda/thor)                          │
#   - Hash#deep_merge (http://www.ruby-forum.com/topic/142809)                 │
#   - RubyTree (https://github.com/evolve75/RubyTree):                         │
#     It has been taken as the initial tree implementation (then customized)   │
#                                                                              │
#                                                                              │
# Project informations:                                                        │
#   - Homepage:        https://github.com/alem0lars/fizzy                      │
#   - Getting started: see README.md in the project root folder                │
#                                                                              │
# License: Apache v2.0 (see below)                                             │
#                                                                              │
# ─────────────────────────────────────────────────────────────────────────────┤
#                                                                              │
# Licensed to the Apache Software Foundation (ASF) under one more contributor  │
# license agreements.  See the NOTICE file distributed with this work for      │
# additional information regarding copyright ownership. The ASF licenses this  │
# file to you under the Apache License, Version 2.0 (the "License"); you may   │
# not use this file except in compliance with the License.                     │
# You may obtain a copy of the License at                                      │
#                                                                              │
#   http://www.apache.org/licenses/LICENSE-2.0                                 │
#                                                                              │
# Unless required by applicable law or agreed to in writing, software          │
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT    │
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.             │
# See the License for the specific language governing permissions and          │
# limitations under the License.                                               │
#                                                                              │
# ─────────────────────────────────────────────────────────────────────────────┘


# ────────────────────────────────────────────────────────────────── Requires ──

# Core modules.
require "fileutils"
require "find"
require "forwardable"
require "json"
require "net/http"
require "ostruct"
require "pathname"
require "securerandom"
require "shellwords"
require "strscan"
require "uri"
require "yaml"

# Try to require `thor` or raise an exception.
begin
  require "thor"
rescue
  puts("\e[31m☠ The gem `thor` is not installed. " +
       "To install run: `gem install thor`. Aborting.\e[0m")
  exit(-1)
end

# Top-level namespace.
module Fizzy
end

# ───────────────────────────────────────────────────────────── Configuration ──

Fizzy::CFG = OpenStruct.new

# Fizzy version.
Fizzy::CFG.version = "2.2.0"

# URL for reporting fizzy issues.
Fizzy::CFG.issues_url = "https://github.com/alem0lars/fizzy/issues"

# Default editor.
Fizzy::CFG.editor = ENV["EDITOR"] || "vim"

# Debug mode.
Fizzy::CFG.debug = ENV["FIZZY_DEBUG"] =~ /^(?:true|yes)$/

# The operating-system which fizzy is running on.
Fizzy::CFG.os = case RUBY_PLATFORM
                  when /darwin/ then :osx
                  when /linux/  then :linux
                  else               :windows
                end

# Remote URL for fizzy static files (must end with a slash).
Fizzy::CFG.static_files_base_url =
  URI("https://raw.githubusercontent.com/alem0lars/fizzy/master/")

# Default fizzy root directory (holding all of the fizzy stuff).
Fizzy::CFG.default_fizzy_dir = Pathname.new(
  ENV["FIZZY_DIR"] ||
  case Fizzy::CFG.os
    when :linux   then "/usr/share/fizzy"
    when :osx     then "~/Library/Application Support/fizzy"
    when :windows then "~/fizzy"
  end
).expand_path

# Default meta file name.
Fizzy::CFG.default_meta_name = "meta.yml"

# Variables inheritance.
Fizzy::CFG.vars = OpenStruct.new(
  yaml_regexp: /^#\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*#\s*/,
  json_regexp: /^\/\*\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*\*\/\s*/,
  parent_dummy_regexp: /none|nothing/i
)

Fizzy::CFG.instantiate_exclude_pattern = /\.git|README/

# ───────────────────────────────────────────────────────────── String ← Exts ──

class String

  # Escapes the underlying object so that it can be safely used in a Bourne
  # shell commandline.
  #
  def shell_escape
    Shellwords.shellescape(self)
  end

end

# ─────────────────────────────────────────────────────────────── Hash ← Exts ──

class Hash

  # Extract `n` sample key/value pairs from the underlying `Hash`.
  def sample(n=1)
    Hash[self.to_a.sample(n)]
  end

  # Perform recursive merge of the current `Hash` (`self`) with the provided one
  # (the `second` argument).
  #
  # The merge have knows how to recurse in both `Hash`es and `Array`s.
  #
  def deep_merge(second)
    merger = proc do |key, v1, v2|
      if Hash === v1 && Hash === v2
        v1.merge(v2, &merger)
      elsif Array === v1 && Array === v2
        (Set.new(v1) + Set.new(v2)).to_a
      else
        v2
      end
    end
    self.merge(second, &merger)
  end

  def fqkeys(prefix="")
    self.inject([]) do |acc, (k, v)|
      prefix_new = prefix.empty? ? k.to_s : "#{prefix}.#{k}"
      acc + (v.is_a?(Hash) ? v.fqkeys(prefix_new) : [prefix_new])
    end
  end

  def slice(*keys)
    self.select{|k, _| keys.include?(k)}
  end

  # ────────────────────────────────────────────────────────────────────────────
  # ☞ Convert keys

  # Return a new `Hash` with all keys converted to `String`s.
  #
  def deep_stringify_keys
    deep_transform_keys{ |key| key.to_s }
  end

  # Destructively convert all keys to `String`s.
  #
  def deep_stringify_keys!
    deep_transform_keys!{ |key| key.to_s }
  end

  # Return a new `Hash` with all keys converted to `Symbol`s, as long as they
  # respond to `to_sym`.
  #
  def deep_symbolize_keys
    deep_transform_keys{ |key| key.to_sym rescue key }
  end

  # Destructively convert all keys to `Symbol`s, as long as they respond to
  # `to_sym`.
  #
  def deep_symbolize_keys!
    deep_transform_keys!{ |key| key.to_sym rescue key }
  end

  # Return a new `Hash` with all keys converted by the block operation.
  #
  def deep_transform_keys(&block)
    deep_transform_keys_in_object(self, &block)
  end

  # Destructively convert all keys by using the block operation.
  #
  def deep_transform_keys!(&block)
    deep_transform_keys_in_object!(self, &block)
  end

  private def deep_transform_keys_in_object(object, &block)
    case object
      when Hash
        object.each_with_object({}) do |(key, value), result|
          result[yield(key)] = deep_transform_keys_in_object(value, &block)
        end
      when Array
        object.map {|e| deep_transform_keys_in_object(e, &block)}
      else object
    end
  end

  private def deep_transform_keys_in_object!(object, &block)
    case object
      when Hash
        object.keys.each do |key|
          value = object.delete(key)
          object[yield(key)] = deep_transform_keys_in_object!(value, &block)
        end
        object
      when Array
        object.map! {|e| deep_transform_keys_in_object!(e, &block)}
      else object
    end
  end

  # ────────────────────────────────────────────────────────────────────────────

end

# ─────────────────────────────────────────────────────────── Pathname ← Exts ──

class Pathname

  # Escapes the string representation of the underlying object,
  # so that it can be safely used in a Bourne shell commandline.
  #
  def shell_escape
    Shellwords.shellescape(self)
  end

end

# ─────────────────────────────────────────────────────────────── Thor ← Exts ──

class Thor
  module Actions

    # Monkey-patch to retrieve the template currently processed.
    old_template = instance_method(:template)
    remove_method :template
    define_method :template, ->(source, *args, &blk) do
      $fizzy_cur_template = source
      old_template.bind(self).(source, *args, &blk)
    end

  end
end

# ───────────────────────────────────────────────────────────── Caller ← Misc ──

class Fizzy::Caller

  def self.info(depth=1)
    parse_caller(caller(depth + 2).first)
  end

  def self.method_name(depth=1)
    parse_caller(caller(depth + 2).first)[:method]
  end

  def self.parse_caller(at)
    if /^(.+?):(\d+)(?::in `(.*)')?/ =~ at
      file   = Regexp.last_match[1]
      line   = Regexp.last_match[2].to_i
      method = Regexp.last_match[3]
      {file: file, line: line, method: method}
    end
  end

end

# ─────────────────────────────────────────────────────────────── Must ← Misc ──

class Object

  def must(name,
           value,
           be: nil,
           ge: nil, gt: nil, le: nil, lt: nil,
           msg: nil)

    def err(msg)
      error msg, exc: ArgumentError
    end

    if !be.nil?
      # 1: type condition.
      if be.is_a?(Class)
        unless value.is_a?(be)
          err "Invalid `#{name}` (value=`#{value}`): must be a `#{be}`"
        end
      end
      if be.is_a?(Array) && be.all? { |b| b.is_a?(Class) }
        unless be.any? { |b| value.is_a?(b) }
          err "Invalid `#{name}` (value=`#{value}`): must be any of `#{be}`"
        end
      end

      # 2: not-`nil` condition.
      err "Invalid `#{name}`: must be not nil" if be == :not_nil && value.nil?
    end

    # 3.1: greater-or-equal-than condition.
    if !ge.nil?
      must name, value, be: Number
      must :ge,  ge,    be: Number
      unless value >= ge
        err "Invalid `#{name}`: `#{value}` must be greater or equal than `#{ge}`"
      end
    end

    # 3.2: greater-than condition.
    if !gt.nil?
      must name, value, be: Number
      must :gt,  gt,    be: Number
      unless value > gt
        err "Invalid `#{name}`: `#{value}` must be greater than `#{gt}`"
      end
    end

    # 3.3: lesser-or-equal-than condition.
    if !le.nil?
      must name, value, be: Number
      must :le,  le,    be: Number
      unless value <= le
        err "Invalid `#{name}`: `#{value}` must be lesser or equal than `#{le}`"
      end
    end

    # 3.4: lesser-than condition.
    if !lt.nil?
      must name, value, be: Number
      must :lt,  lt,    be: Number
      unless value < lt
        err "Invalid `#{name}`: `#{value}` must be lesser than `#{lt}`"
      end
    end

    # 3: ad-hoc condition.
    if block_given?
      result = yield(name, value)
      if result.is_a?(Array)
        err "Invalid `#{name}`: #{result[1]}" unless result[0]
      else
        err "Invalid `#{name}`: wrong value `#{value}`" unless result
      end
    end
  end

end

# ──────────────────────────────────────────────────── Abstract method ← Misc ──

# Exception raised when an abstract method is called.
#
class AbstractMethodCalled < StandardError
end

class Module
  # Define one or more abstract methods with given names in a class or module.
  # When called, the abstract method will raise an `AbstractMethodCalled`
  # exception with a helpful message.
  #
  # @example
  #   class AbstractClass
  #     abstract_method :foo
  #   end
  #
  #   class ConcreteClass < AbstractClass
  #     def foo
  #       42
  #     end
  #   end
  #
  #   AbstractClass.new.foo # raises AbstractMethodCalled
  #   ConcreteClass.new.foo # => 42
  #
  # @param [Array<Symbol>] names the names of defined abstract methods
  #
  def abstract_method(*names)
    definitor = self

    names.each do |name|
      define_method name do |*args|
        raise AbstractMethodCalled,
              "Called unimplemented abstract method #{self.class}##{name} " +
              "(defined in #{definitor.class.name.downcase} #{definitor})."
      end
    end
  end
end

# ───────────────────────────────────────────────────────── Typesystem ← Misc ──

module Fizzy::TypeSystem

  # Check/convert type of the provided `value`,
  # according to the argument `type`.
  #
  # The argument `name` is a logical name to be used for the value,
  # used when logging messages. It can be anything.
  #
  # If `strict` is `true`, then no type convertion/normalization is done;
  # otherwise, try to guess the correct type.
  #
  def typize(name, value, type: nil, strict: false)
    if type.nil? || (type.to_s.end_with?("?") && value.nil?)
      value
    else
      case type.to_s.gsub(/\?$/, "").to_sym
        when :string, :str
          strict ? _ensure_type!(name, value, String) : value.to_s
        when :symbol, :sym
          strict ? _ensure_type!(name, value, Symbol) : value.to_s.to_sym
        when :integer, :int
          strict ? _ensure_type!(name, value, Integer) : Integer(value)
        when :boolean, :bool
          if strict
            _ensure_type!(name, value, TrueClass, FalseClass)
          else
            if value.nil?
              nil
            elsif value.is_a?(TrueClass) || value.to_s == "true"
              true
            elsif value.is_a?(FalseClass) || value.to_s == "false"
              false
            else
              error("Invalid `#{value}` for value `#{name}`: " +
                    "it can't be converted to a boolean.")
            end
          end
        when :path, :pth then
          if strict && !File.exist?(value)
            error("Invalid `#{name}`: `#{value}` doesn't exist")
          else
            Pathname.new(value).expand_path
          end
        when :file then
          if strict && !File.file?(value)
            error("Invalid `#{name}`: `#{value}` isn't a file")
          else
            Pathname.new(value).expand_path
          end
        when :directory, :dir then
          if strict && !File.directory?(value)
            error("Invalid `#{name}`: `#{value}` isn't a directory")
          else
            Pathname.new(value).expand_path
          end
        else
          error("Unhandled type `#{type}`. If you need support for a new " +
                "type, open an issue at `#{Fizzy::CFG.issues_url}`.")
      end
    end
  end

end

# ───────────────────────────────────────────────────────────────── Io ← Core ──

module Fizzy::IO

  # Get the shell object.
  # It will be lazily instantiated.
  def shell
    @shell ||= Thor::Shell::Color.new
  end

  # Ask a question to the user.
  #
  # The message is made by the `question` string, with some additions (like
  # `?` sign).
  #
  # The available quiz types are:
  # - `:bool`: Boolean quiz, the user can respond with `yes` or `no` (or
  #            alternatives, see regexes below). A boolean value is returned.
  # - `:string`: Normal quiz, the user is prompt for a question and if the
  #              answer isn't empty is returned.
  #
  def quiz(question, type: :bool)
    answer = shell.ask("#{question.strip}? ", :magenta)
    case type
      when :bool
        if answer =~ /y|ye|yes|yeah|ofc/i
          true
        elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
          false
        else
          tell("Answer misunderstood", :yellow)
          quiz(question, type: type)
        end
      when :string
        if answer.empty?
          warning("Empty answer", ask_continue: false)
          quiz(question, type: type)
        else
          answer
        end
      else error("Unhandled question type: `#{type}`.")
    end
  end

  def debug(msg)
    caller_info = caller.
      map { |c| c[/`.*'/][1..-2].split(" ").first }.
      uniq[0..2].
      join(" → ")

    tell(colorize("⚫ ", :magenta) +
         colorize("<", :blue) +
         colorize(caller_info, :cyan) +
         colorize(">", :blue) +
         colorize(": #{msg}", :white)) if Fizzy::CFG.debug
  end

  # Display an informative message (`msg`) to the user.
  #
  # The `prefix` argument should contain some text displayed before the
  # message, typically to show the context which the message belongs to.
  #
  def info(prefix, msg)
    tell(colorize("☞ ", :magenta) +
         colorize(prefix, :cyan) +
         colorize(" #{msg}", :white))
  end

  # Display an informative message (`msg`) to the user.
  #
  # If `ask_continue` is `true`, the user can interactively choose to stop
  # the program or exit (with exit status `-1`).
  #
  def warning(msg, ask_continue: true)
    tell(colorize("☞ ", :magenta) + colorize(msg, :yellow))
    exit(-1) if ask_continue && !quiz("continue")
  end

  # Display an error message (`msg`) to the user. Before returning, the
  # program will exit (with exit status `-1`).
  #
  def error(msg, exc: nil)
    must "message", msg, be: String

    tell(colorize("☠ ", :magenta) + colorize(msg, :red))

    if exc
      raise exc.new(msg)
    else
      exit(-1)
    end
  end

  # Tell something to the user.
  # It's a proxy method to `Thor::Shell::Color.say`.
  #
  def tell(*args)
    shell.say(*args)
  end

  # Colorize the provided string.
  # It's a proxy method to `Thor::Shell::Color.set_color`.
  #
  def colorize(*args)
    shell.set_color(*args)
  end

  # ──────────────────────────────────────────────────────────────────────────
  # ☞ Well-known messages

  # Get colorized success symbol.
  #
  def ✔
    colorize("✔", :green)
  end

  # Get colorized error symbol.
  #
  def ✘
    colorize("✘", :red)
  end

  # ──────────────────────────────────────────────────────────────────────────

end

# ───────────────────────────────────────────────────── Base lexer ← Grammars ──

class Fizzy::BaseLexer

  include Fizzy::IO

  def initialize(string)
    @base   = StringScanner.new(string)
    @rules  = []
    @tokens = []
  end

  def ignore(pattern)
    @rules << [pattern, [:SKIP]]
  end

  def tokens(patterns, *names)
    Array(patterns).map do |pattern|
      case pattern
      when Regexp then pattern
      when String then Regexp.new(pattern)
      else             Regexp.new(pattern.to_s)
      end
    end.each do |pattern|
      @rules << [pattern, names]
    end
  end

  def token(patterns, name)
    tokens(patterns, name)
  end

  def keyword(name)
    token(Regexp.new(name), name)
  end

  def next_token
    build_tokens if @tokens.empty?
    t = @tokens.shift
    t.first == :SKIP ? next_token : t
  end

private

  # (Re)build the list of tokens.
  # Every token is: `[value, token_name]`.
  def build_tokens
    @tokens  = []
    @tokens += find_tokens until @base.eos?
    @tokens << [false, false] # Last token, meaning EOS.
    debug("Built tokens: `#{@tokens}`.")
  end

  def find_tokens
    @rules.each do |pattern, tokens|
      matched_substring = @base.scan(pattern)
      unless matched_substring.nil?
        if @base[1].nil? # No captures, return the matched string.
          error("Only one token, not `#{tokens.length}` (`#{tokens}`) should " +
                "be provided.") if tokens.length != 1
          return [[tokens.first, matched_substring]]
        else
          captures, base_idx = [], 0
          captures << @base[base_idx] until @base[base_idx += 1].nil?
          error("You need to provide `#{captures.length}` tokens, instead of " +
                "`#{tokens.length}`.") unless captures.length == tokens.length
          return tokens.zip(captures)
        end
      end
    end
    error("Unexpected characters.")
  end

end

# ───────────────────────────────────────────────────────────────────── Lexer ──

class Fizzy::LogicLexer < Fizzy::BaseLexer

  def initialize(string)
    super

    ignore(/\s+/)

    token(/=/,    :EQ)
    token(/&&/,   :AND)
    token(/\|\|/, :OR)
    token(/\(/,   :LBRACKET)
    token(/\)/,   :RBRACKET)

    tokens(/(f\?)(#{name_with("-_")})/,  :FEATURE_PREFIX, :FEATURE_NAME)
    tokens(/(v\?)(#{name_with("-_.")})/, :VAR_PREFIX,     :VAR_NAME)

    token(/.+/, :VALUE) # Anything that would otherwise not match is a value.
  end

private

  def name_with(symbols)
    /\w+(?:[#{symbols}]\w+)*/
  end

end

# ───────────────────────────────────────────────────────────────── Evaluator ──

class Fizzy::LogicEvaluator

  include Fizzy::IO

  def initialize(receiver)
    @receiver = receiver
    @stack    = []
  end

  def result
    res = @stack.first
    debug("Retrieving result from stack `#{@stack}`: `#{res}`.")
    res
  end

  def and
    arg1 = @stack.pop
    arg2 = @stack.pop
    result = (arg1 == true) && (arg2 == true)
    @stack << result
    debug("Performed logical `and` between `#{arg1}` and `#{arg2}`, " +
          "evaluated to `#{result}`.")
    debug_stack_state
  end

  def or
    arg1 = @stack.pop
    arg2 = @stack.pop
    result = arg1 == true || arg2 == true
    @stack << result
    debug("Performed logical `or` between `#{arg1}` and `#{arg2}`, " +
          "evaluated to `#{result}`.")
    debug_stack_state
  end

  def has_feature?(name)
    result = @receiver.has_feature?(name)
    @stack << result
    debug("Parsed feature `#{name}`: it's #{result ? "" : "not "}available.")
    debug_stack_state
  end

  def has_variable?(name)
    var_value = @receiver.get_var(name)
    result = !var_value.nil?
    @stack << result
    debug("Parsed variable `#{name}` with value `#{var_value}`: " +
          "it's #{result ? "" : "not "}available.")
    debug_stack_state
  end

  def variable_value?(name, expected_value)
    var_value = @receiver.get_var(name)
    result = var_value == expected_value
    @stack << result
    debug("Parsed variable `#{name}` with value `#{var_value}`: " +
          "it's #{result ? "" : "not "}equal to `#{expected_value}`.")
    debug_stack_state
  end

  protected def debug_stack_state
    debug("Stack state is: `#{@stack}`.")
  end

end

# ────────────────────────────────────────────────────────────── Logic Parser ──

#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.14
# from Racc grammer file "".
#

require 'racc/parser.rb'
module Fizzy
  class LogicParser < Racc::Parser

module_eval(<<'...end parser.y/module_eval...', 'parser.y', 31)

  def parse(receiver, arg)
    @yydebug = Fizzy::CFG.debug
    @lexer   = Fizzy::LogicLexer.new(arg)
    @eval    = Fizzy::LogicEvaluator.new(receiver)
    do_parse
    @eval.result
  end

  def next_token
    @lexer.next_token
  end


# vim: set filetype=racc :
...end parser.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
     3,     3,     4,     4,     5,     5,     3,     3,     4,     4,
     5,     5,     7,     8,     7,    15,     7,     8,    17,     6,
    10,    11,    12,    16 ]

racc_action_check = [
     7,     8,     7,     8,     7,     8,     3,     0,     3,     0,
     3,     0,     9,     9,    14,     9,     2,     2,    16,     1,
     4,     5,     6,    11 ]

racc_action_pointer = [
     2,    19,    13,     1,    12,    11,    22,    -5,    -4,     9,
   nil,    21,   nil,   nil,    11,   nil,     7,   nil ]

racc_action_default = [
    -8,    -8,    -1,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
    -5,    -6,    18,    -3,    -4,    -2,    -8,    -7 ]

racc_goto_table = [
     2,     1,   nil,     9,   nil,   nil,   nil,    13,    14 ]

racc_goto_check = [
     2,     1,   nil,     2,   nil,   nil,   nil,     2,     2 ]

racc_goto_pointer = [
   nil,     1,     0 ]

racc_goto_default = [
   nil,   nil,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 13, :_reduce_none,
  3, 14, :_reduce_none,
  3, 14, :_reduce_3,
  3, 14, :_reduce_4,
  2, 14, :_reduce_5,
  2, 14, :_reduce_6,
  4, 14, :_reduce_7 ]

racc_reduce_n = 8

racc_shift_n = 18

racc_token_table = {
  false => 0,
  :error => 1,
  :EQ => 2,
  :AND => 3,
  :OR => 4,
  :LBRACKET => 5,
  :RBRACKET => 6,
  :FEATURE_PREFIX => 7,
  :FEATURE_NAME => 8,
  :VAR_PREFIX => 9,
  :VAR_NAME => 10,
  :VALUE => 11 }

racc_nt_base = 12

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "EQ",
  "AND",
  "OR",
  "LBRACKET",
  "RBRACKET",
  "FEATURE_PREFIX",
  "FEATURE_NAME",
  "VAR_PREFIX",
  "VAR_NAME",
  "VALUE",
  "$start",
  "target",
  "exp" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

# reduce 2 omitted

module_eval(<<'.,.,', 'parser.y', 20)
  def _reduce_3(val, _values, result)
     @eval.and 
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 21)
  def _reduce_4(val, _values, result)
     @eval.or  
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 23)
  def _reduce_5(val, _values, result)
     @eval.has_feature?(val[1])            
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 24)
  def _reduce_6(val, _values, result)
     @eval.has_variable?(val[1])           
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 25)
  def _reduce_7(val, _values, result)
     @eval.variable_value?(val[1], val[3]) 
    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

  end   # class LogicParser
  end   # module Fizzy

# ──────────────────────────────────────────────────────── Environment ← Core ──

# Utilities to retrieve informations about the host environment & system.
#
module Fizzy::Environment

  include Fizzy::IO

  # Find an executable called `name` in the `$PATH`.
  # Note: `name` can also be a path pointing to the executable.
  #
  def which?(name)
    exts = ENV["PATHEXT"] ? ENV["PATHEXT"].split(";") : [""]
    ENV["PATH"].split(File::PATH_SEPARATOR).each do |path|
      exts.each do |ext|
        exe = File.join(path, "#{cmd}#{ext}")
        return exe if File.executable?(exe) && !File.directory?(exe)
      end
    end
    return nil
  end

  # Return the environment variable matching the provided `name`.
  #
  def get_env(name, default: nil)
    ENV[name.to_s] || default
  end

  # Same of `get_env`, but raise an error if the environment variable hasn't
  # been found or is `nil`.
  #
  def get_env!(name)
    value = get_env(name)
    error("Undefined environment variable: `#{name}`.") if value.nil?
    value
  end

  # Check if the underlying operating system is MacOSX.
  #
  def is_osx?
    Fizzy::CFG.os == :osx
  end

  # Check if the underlying operating system is GNU/Linux.
  #
  def is_linux?
    Fizzy::CFG.os == :linux
  end

  # Check if the underlying operating system is Windows.
  #
  def is_windows?
    Fizzy::CFG.os == :windows
  end

  # Execute a function, based on the underlying operating system.
  #
  def case_os(osx: nil, linux: nil, windows: nil)
    if is_osx?
      osx.respond_to?(:call) ? osx.call : osx
    elsif is_linux?
      linux.respond_to?(:call) ? linux.call : linux
    elsif is_windows?
      windows.respond_to?(:call) ? windows.call : windows
    else
      error("Unrecognized operating system.")
    end
  end

  def xdg_config_home(name)
    Pathname.new(get_env(:XDG_CONFIG_HOME) || "~/.config").
      expand_path.
      join(name.to_s)
  end

end

# ────────────────────────────────────────────────────────── Execution ← Core ──

# Utilities to start and manage programs execution.
#
module Fizzy::Execution

  include Fizzy::IO

  # Execute the provided shell command (`cmd`).
  # If `as_su` is `true` the command is executed as super user
  # (i.e. as root, using sudo).
  #
  def exec_cmd(cmd, as_su: false, chdir: nil)
    cmd = cmd.map(&:to_s).map(&:shell_escape).join(" ") if cmd.is_a?(Array)

    full_cmd = as_su ? "sudo #{cmd}" : cmd

    run_mode = defined?(@run_mode) ? @run_mode : :normal

    really_run = case run_mode
                   when :normal then true
                   when :paranoid
                     quiz("Do you want to run command `#{full_cmd}`")
                   when :dry then false
                   else true
                 end

    if really_run || run_mode == :dry
      tell(as_su ? "[sudo] #{cmd}" : cmd, :magenta)
    end

    status = nil
    if really_run
      if chdir
        FileUtils.cd(chdir) do
          status = system(full_cmd)
        end
      else
        status = system(full_cmd)
      end
      warning("Command `#{full_cmd}` failed.") unless status
    end
    status
  end

end

# ───────────────────────────────────────────────────────── Filesystem ← Core ──

# Utilities to interact with the filesystem.
#
module Fizzy::Filesystem

  include Fizzy::IO
  include Fizzy::Execution

  # Find a YAML file prefixed by `path` (guess extension name).
  #
  def find_yaml_path(path)
    if path.file?
      path
    else
      %w(yml yaml).map do |ext|
        p = Pathname.new("#{path}.#{ext}")
        p if p.file?
      end.compact.first
    end
  end

  # Check if the provided `path` is an existing directory.
  #
  # If `writable` is true, also check if `path` points to a writable
  # directory.
  #
  def existing_dir(path, writable: true)
    dir_path = path
    dir_path = dir_path.dirname until dir_path.directory?
    (writable && !dir_path.writable?) ? nil : dir_path
  end

  # Return an object (`OpenStruct`), which contains all of the well-known
  # paths.
  #
  # Before adding a path, some validations are executed to ensure that path
  # points to a correct thing.
  #
  # You can skip some validations and filling some paths:
  # - `valid_cfg`:
  #   - If `false` don't validate and fill paths related to the configuration.
  #   - If `readonly`, don't validate writability for configuration.
  # - `valid_inst`:
  #   - If `false` don't validate and fill paths related to the configuration
  #     instances.
  #   - If `true`, be sure to provide the argument `cur_inst_name`, which
  #     should contain the name of the current instance (the instance that
  #     should be used).
  #   - If `readonly`, don't validate writability for instance.
  #
  def prepare_storage(root_path,
                      valid_meta: true, valid_cfg: true, valid_inst: true,
                      meta_name: nil, cur_cfg_name: nil, cur_inst_name: nil)
    root_path = Pathname.new(root_path).expand_path

    # Paths based on internal conventions.
    parent_path = root_path.dirname

    cfg_path = root_path.join("cfg")
    cur_cfg_path = cfg_path.join(cur_cfg_name) if cur_cfg_name
    cur_cfg_vars_path = cur_cfg_path.join("vars") if cur_cfg_path
    cur_cfg_meta_path = find_yaml_path(cur_cfg_path.join(meta_name)) if cur_cfg_path && meta_name

    inst_path = root_path.join("inst")
    cur_inst_path = inst_path.join(cur_inst_name) if cur_inst_name
    cur_inst_vars_path = cur_inst_path.join("vars") if cur_inst_path
    cur_inst_meta_path = find_yaml_path(cur_inst_path.join(meta_name)) if cur_inst_path && meta_name

    # Validate `root_path`.
    if !root_path.directory? && !parent_path.writable?
      error("Cannot create directory: `#{root_path}`.")
    end
    if root_path.file?
      if quiz("`#{root_path}` already exists but is a regular file. Remove")
        exec_cmd("rm #{root_path.shell_escape}",
                 as_su: File.owned?(root_path))
      else
        error("File `#{root_path}` already exists but is needed as fizzy " +
              "root directory. Aborting.")
      end
    end

    # XXX This check is for preventing errors when we don't want to create the
    #     directory structure. Should we add a dedicate argument?
    if !valid_cfg && !valid_inst && root_path.directory? && !root_path.writable?
      error("No write permissions in Fizzy storage at path `#{root_path}`.")
    end

    if valid_cfg
      unless root_path.directory?
        error("The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`).")
      end
      if cur_cfg_path.nil? || !cur_cfg_path.directory? || !(valid_cfg == :readonly || cur_cfg_path.writable?)
        error("The current configuration `#{cur_cfg_name}` is invalid: " +
              "it's not a valid directory.")
      end
      if valid_meta && (cur_cfg_meta_path.nil? || !cur_cfg_meta_path.file?)
        error("The meta file path `#{cur_cfg_meta_path}` is invalid.")
      end
      if cur_cfg_vars_path.nil? || !cur_cfg_vars_path.directory?
        error("The variables directory `#{cur_cfg_vars_path}` is invalid.")
      end
    end

    if valid_inst
      unless root_path.directory?
        error("The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`).")
      end
      if cur_inst_path.nil? || !cur_inst_path.directory? || !(valid_inst == :readonly || cur_inst_path.writable?)
        error("The current instance `#{cur_inst_name}` is invalid: it's " +
              "not a valid directory.")
      end
      if valid_meta && (cur_inst_meta_path.nil? || !cur_inst_meta_path.file?)
        error("The meta file path `#{cur_inst_meta_path}` is invalid.")
      end
      if cur_inst_vars_path.nil? || !cur_inst_vars_path.directory?
        error("The variables directory `#{cur_inst_vars_path}` is invalid.")
      end
    end

    # Create non-existing internal directories.
    FileUtils.mkdir_p(root_path) unless root_path.directory?
    [cfg_path, inst_path].each do |dir_path|
      unless dir_path.directory?
        FileUtils.mkdir_p(dir_path)
        exec_cmd("chmod a+w #{dir_path.shell_escape}",
                 as_su: File.owned?(dir_path))
      end
    end
    if cur_inst_path && !cur_inst_path.directory?
      FileUtils.mkdir_p(cur_inst_path)
    end

    # Return the known storage paths.
    OpenStruct.new(
      root:          root_path,
      cfg:           cfg_path,
      cur_cfg:       cur_cfg_path,
      cur_cfg_vars:  cur_cfg_vars_path,
      cur_cfg_meta:  cur_cfg_meta_path,
      inst:          inst_path,
      cur_inst:      cur_inst_path,
      cur_inst_vars: cur_inst_vars_path,
      cur_inst_meta: cur_inst_meta_path)
  end

end

# ─────────────────────────────────────────────────────── Setup ← Vars ← Core ──

module Fizzy::Vars
  class Setup

    include Fizzy::IO
    include Fizzy::Filesystem

    def initialize(vars_dir_path, name, bindings)
      @binding = bindings
      @vars_dir_path = vars_dir_path
      @name          = name
    end

    # Setup the variables that will be used during ERB processing.
    #
    # Those variables will be set into an instance field called `@vars`.
    #
    # After calling this method, you can directly access the variables using
    # `@vars` or using the attribute reader `vars`.
    #
    def run
      setup_vars(@vars_dir_path, @name)
    end

  protected

    def setup_vars(vars_dir_path, name)
      fmt, content = read_vars(vars_dir_path, name)
      error("Invalid vars: `#{name}`.") if fmt == nil || content == nil
      self_vars    = parse_vars(name, fmt, content)
      parents      = parse_parents_vars(fmt, content)
      parents_vars = merge_parents_vars(vars_dir_path, parents)
      merge_with_parents_vars(self_vars, parents_vars)
    end

    def read_vars(vars_dir_path, name)
      yaml_file_path = find_yaml_path(vars_dir_path.join(name)) unless vars_dir_path.nil? || name.nil?

      if yaml_file_path
        [:yaml, File.read(yaml_file_path)]
      elsif !name.nil? && ENV.has_key?(name)
        [:json, ENV[name]]
      else
        [nil, nil]
      end
    end

    def parse_vars(name, fmt, content)
      content = ERB.new(content).result(@binding)
      case fmt
        when :yaml
          begin
            YAML.load(content) || {}
          rescue Psych::SyntaxError => e
            error("Invalid syntax in YAML `#{name}`: #{e.message}")
          end
        when :json
          begin
            JSON.parse(content)
          rescue JSON::JSONError => e
            error("Invalid JSON `#{name}`: #{e.message}.")
          end
        else error("Unrecognized format: `#{fmt}`")
      end.deep_symbolize_keys
    end

    def parse_parents_vars(fmt, content)
      parents_regexp = case fmt
                         when :yaml then Fizzy::CFG.vars.yaml_regexp
                         when :json then Fizzy::CFG.vars.json_regexp
                         else       error("Unrecognized format: `#{fmt}`.")
                       end
      if md = content.match(parents_regexp)
        md[:parents].split(",")
                    .map(&:strip)
                    .reject{|p| p =~ Fizzy::CFG.vars.parent_dummy_regexp}
      else
        []
      end
    end

    def merge_with_parents_vars(self_vars, parents_vars)
      parents_vars.deep_merge(self_vars)
    end

    def merge_parents_vars(vars_dir_path, parents)
      parents.inject([]) do |acc, parent| # Vars for each parent.
        parent_vars = setup_vars(vars_dir_path, parent)
        acc << parent_vars
      end.inject({}) do |acc, parent_vars| # Merge them.
        acc.deep_merge(parent_vars)
      end
    end

  end
end

# ───────────────────────────────────────────────────── Filters ← Vars ← Core ──

module Fizzy::Vars

  module Filters
    def self.define(name, description: nil, &block)
      @filters ||= []
      @filters << Filter.new(name, description.strip, &block)
    end

    def self.apply(blob)
      if filter = (@filters || []).find{|f| f.match?(blob)}
        filter.apply(blob)
      else
        blob
      end
    end

    class Filter

      include Fizzy::IO

      attr_reader :name, :desc

      def initialize(name, desc, &block)
        @name   = name
        @desc   = desc
        @block  = block
        @regexp = /^<\{\s*(?<name>#{@name})\s*(?<args>\S+)\s*\}>$/
      end

      def match?(blob)
        return false unless blob.is_a?(String) || blob.is_a?(Symbol)
        @regexp =~ blob.to_s
      end

      def apply(blob)
        md = @regexp.match(blob)
        return if md.nil?
        args = md[:args]
        def args.split_by_separator(sep=",")
          self.split(/(?:\s*[#{sep}]\s*)/)
        end
        @block.call(args)
      end
    end
  end

end

# ─────────────────────────────────────────────────── Retriever ← Vars ← Core ──

module Fizzy::Vars
  class Retriever

    include Fizzy::IO
    include Fizzy::TypeSystem

    def initialize(vars)
      @vars = vars
    end

    # Return the variables matching the provided `name`.
    #
    # The result is normally a list of the matching variables; but if `expand`
    # is `true`, empty list is expanded to `nil` and a list of one element is
    # expanded to that element.
    #
    def get(var_name, type: nil, strict: false, single_match: false, expand: true)
      var = _get_var(@vars, var_name, single_match: single_match)
      var = _typize_var(var_name, var, type, strict)

      if expand
        case var.length
          when 0 then nil
          when 1 then var.first
          else        var
        end
      else
        var
      end
    end

    # Accept a list of variables (`vars` argument) and ensure they are correctly
    # typed, according to `type`.
    #
    # See `Fizzy::TypeSystem#typize` for more details.
    #
    protected def _typize_var(name, variable, type, strict)
      Array(variable).map do |var|
        typize(name, var, type: type, strict: strict)
      end
    end

    protected def _ensure_type!(name, var, *types)
      if types.any?{|type| var.is_a?(type)}
        var
      else
        error("Invalid type for variable `#{name}`: " +
              "it's not a `#{type.name}`.")
      end
    end

    # Returns a list of variables matching the provided `name`, chosen from `vars`.
    #
    # The argument `single_match` can be one of `[:force, true, false]`, to
    # respectively force, restrict to, don't return a single match (the first).
    #
    # This method effectively implements the logic to retrieve variables.
    #
    protected def _get_var(vars, name, single_match: :force)
      dot_split_regexp = /([^.]+)(?:\.|$)/

      name.to_s
          .scan(dot_split_regexp)
          .map{|match_group| match_group[0]}
          .reject(&:empty?)
          .inject(vars) do |current_objects, name_component|

        # Intermediate `current_objects` are lists because every step returns
        # a list.
        # If a step is not-final (i.e. intermediate), we need to be sure there
        # is only one element.
        if current_objects.is_a?(Array)
          if current_objects.length == 1
            current_objects = current_objects.first
          else
            error("Variabile name diverges: multiple intermediate paths are " +
                  "taken (`[#{current_objects}]`).")
          end
        end

        # Fill `next_objects`.
        next_objects = if current_objects.has_key?(name_component)
                         # Exact match.
                         Array[current_objects[name_component]]
                       elsif current_objects.has_key?(name_component.to_sym)
                         # Exact match.
                         Array[current_objects[name_component.to_sym]]
                       else
                         # Check if there are elements with key matching
                         # `name_component` as regexp.
                         # Return `nil` if nothing is found.
                         current_objects.select do |k, v|
                           k.to_s =~ Regexp.new(/^#{name_component}$/)
                         end.values
                       end

        # Filter `next_objects`.
        next_objects = next_objects.map{|e| Fizzy::Vars::Filters.apply(e)}

        # Adjust `next_objects`, according to `single_match` argument.
        next_objects = if single_match
                         if single_match == :force && next_objects.length != 1
                           error("Expected a single match for variable " +
                                 "`#{name}`, but instead got " +
                                 "`#{next_objects.length}`")
                         end
                         next_objects.first
                       else
                         next_objects
                       end

        if next_objects.nil? ||
           (next_objects.is_a?(Array) && next_objects.empty?)
          break nil
        end
        next_objects
      end
    end

  end
end

# ───────────────────────────────────────────────────────── Api ← Vars ← Core ──

module Fizzy::Vars

  include Fizzy::IO

  attr_reader :vars

  # Return a list of the available variables files.
  #
  def avail_vars(vars_dir_path)
    Pathname.glob(vars_dir_path.join("*"))
  end

  # See `Fizzy::Vars::Setup#run`
  #
  def setup_vars(vars_dir_path, name)
    info("vars: ", name)
    @vars = Fizzy::Vars::Setup.new(vars_dir_path, name, binding).run()
  end

  # See `Fizzy::Vars::Retriever#run`
  #
  def var(var_name, **opts)
    Fizzy::Vars::Retriever.new(@vars).get(var_name, **opts)
  end
  alias_method :get_var, :var # NOTE: For backward compatibility

  # Same of `var`, but raise an error if the variable hasn't been found or
  # is `nil`.
  #
  def var!(var_name, **opts)
    value = var(var_name, **opts)
    value.nil? ? error("Undefined variable: `#{var_name}`.") : value
  end
  alias_method :get_var!, :var! # NOTE: For backward compatibility

  # Check if the feature with the provided name (`feature_name`) is enabled.
  #
  # Since the features are defined just using variables, before calling this
  # method be sure that `setup_vars` has already been called.
  #
  def has_feature?(feature_name)
    get_var!("features", single_match: :force).include?(feature_name.to_s)
  end

  # Filter the values associated to the features, keeping only those
  # associated to available features.
  #
  def data_for_features(info, sep: nil)
    data = []

    info.each do |feature_name, associated_value|
      if has_feature?(feature_name.to_sym)
        if associated_value.respond_to?(:call)
          data << associated_value.call
        else
          data << associated_value
        end
      end
    end

    if data.length == 1
      def data.inspect
        first
      end
    elsif sep
      def data.inspect
        join(sep)
      end
    end

    data
  end

end

# ───────────────────────────────────────────────────────────── Locals ← Core ──

module Fizzy::Locals

  extend Forwardable
  include Fizzy::IO

  def_delegators :@locals_proxy, :local, :local!, :local?, :prefix?

  # Entry point for using the DSL defined by `Proxy` class.
  # The DSL is directly accessible inside the provided block.
  #
  def define_locals(&block)
    error("No requirements specification provided.") unless block_given?
    @locals_proxy = Fizzy::Locals::Proxy.new(self)
    @locals_proxy.instance_eval(&block)
  end

  # DSL used for defining locals.
  #
  class Proxy

    include Fizzy::IO
    include Fizzy::TypeSystem

    attr_reader :locals

    def initialize(receiver)
      @receiver = receiver
      @locals   = {}
      @prefix   = nil
      @prefix_history = []
    end

    # ──────────────────────────────────────────────────────────────────────────
    # ☞ DSL definition

    # Create a new `local` fetching the value from the corresponding `variable`.
    #
    def variable(name, *args, **opts)
      name = name.to_s.to_sym

      var = _get_var(name, **opts.slice(:type, :strict))

      _set_local(opts.fetch(:as, name),
                 var.nil? ? opts.fetch(:default, nil) : var)
    end

    # Create a new computed `local`, based upon other locals.
    #
    def computed(name, **typize_opts, &block)
      name = name.to_s.to_sym
      error("Invalid local name `#{name}`: it's blank.") if name.empty?
      error("Cannot compute local `#{name}`.") unless block_given?
      value = @receiver.instance_exec(&block)
      value = typize(name, value, **typize_opts) if typize_opts.length > 0
      _set_local(name, value)
    end

    # Access the value of a local.
    #
    def local(name)
      @locals[name.to_s.to_sym]
    end

    # Access the value of a local or raise an error if it's not defined.
    #
    def local!(name)
      value = local(name)
      error("Undefined local `#{name}`.") if value.nil?
      value
    end

    # If all locals identified by `names` are available, evaluate the block
    # passing the locals' values.
    #
    def local?(*names, &block)
      names.collect{|name| local(name)}.compact.length == names.length
    end

    def prefixed(var, as: nil, optional: false)
      error("A block is required") unless block_given?
      unless @receiver.get_var(var.to_s.gsub(/\.$/, ""))
        return if optional
        error("Invalid variable prefix: `#{var}`.")
      end
      @prefix = {var: var, local: as}
      @prefix_history << @prefix
      yield
      @prefix = nil
    end

    # Return `true`, if a prefix starting with the provided `prefix` has
    # been defined; otherwise, `false`.
    #
    def prefix?(prefix)
      @prefix_history.any?{|p| p[:local].to_s.start_with?(prefix.to_s)}
    end

    # ──────────────────────────────────────────────────────────────────────────

    def _get_var(name, **opts)
      name = @prefix && @prefix[:var] ? "#{@prefix[:var]}#{name}" : name
      @receiver.get_var(name.to_s.to_sym, **opts)
    end

    def _set_local(name, value)
      name = @prefix && @prefix[:local] ? "#{@prefix[:local]}#{name}" : name
      @locals[name.to_s.to_sym] = value
    end

  end

end

# ────────────────────────────────────────────────────── Meta commands ← Core ──

# Manage commands declared in the meta file.
#
module Fizzy::MetaCommands

  # Return a data structure containing the commands that can be specified in
  # the meta file.
  #
  # The data structure defines:
  # - The available command types (`available_commands.keys`).
  # - (Optionally) A validator that can be used to validate type-specific
  #   validation rules.
  # - The command executor: A `Lambda` containing the code used for executing
  #   that command.
  #
  def available_commands
    { sync: {
        validator: lambda { |spec|
          if spec.has_key?(:dst)
            spec[:dst] = Pathname.new(spec[:dst]).expand_path
          end
          spec.has_key?(:repo) && spec.has_key?(:dst)
        },
        executor: lambda{|spec| Fizzy::Sync.perform(spec[:dst], spec[:repo])}
      },
      download: {
        validator: lambda { |spec|
          # 1. Validate.
          status   = spec.has_key?(:url)
          status &&= spec.has_key?(:dst)
          # 2. Normalize.
          if status
            spec[:url] = URI(spec[:url])
            spec[:dst] = Pathname.new(spec[:dst]).expand_path
          end
          status
        },
        executor: lambda { |spec|
          res = Net::HTTP.get_response(spec[:url])
          if res.is_a?(Net::HTTPSuccess)
            # TODO atm it requires the current user has write access.
            #      refactor when a more robust permission mgmt is implemented.
            FileUtils.mkdir_p(spec[:dst].dirname)
            spec[:dst].write(res.body)
          else
            error("Network error: cannot retrieve `#{spec[:url]}`.")
          end
        }
      }
    }
  end

end

# ────────────────────────────────────────────────────────── Meta info ← Core ──

# Access informations declared in the meta file.
#
module Fizzy::MetaInfo

  include Fizzy::IO
  include Fizzy::Vars

  # Return the normalized and validated meta object.
  #
  # Be sure to call `setup_vars` before calling this method.
  #
  def get_meta(meta_path, vars_path, elems_base_path, verbose)
    tell("Getting meta informations.", :blue)

    begin
      meta = YAML.load(File.read(meta_path)).deep_symbolize_keys
    rescue Psych::SyntaxError => exc
      error("Failed to parse meta file: `#{meta_path}`. " +
            "Reason: `#{exc.message}`.")
    end

    meta[:all_elems_count] = meta[:elems].count

    # ──────────────────────────────────────────────────────────────────────────
    # ☞ Step 1: Normalize elements

    elem_erb_excluded_fields = %i(only)

    meta[:elems] = [] unless meta.has_key?(:elems)

    meta[:elems] = meta[:elems].each_with_index.collect do |elem, idx|
      elem_identifier = elem[:name] || "src = #{elem[:src]}"
      info("\nElement: ", elem_identifier) if verbose

      # Step 1.1: Validate `only` and determine if the element is selected.
      if elem.has_key?(:only) && !(elem[:only].is_a?(Hash) || elem[:only].is_a?(String))
        error("The configuration element `#{elem_identifier}` has invalid " +
              "`only`: it's not a `Hash`.")
      end
      selected = selected_by_only?(elem[:only], verbose)

      # Step 1.2: Pre-process strings with ERB.
      if selected
        elem.each do |k, v|
          unless elem_erb_excluded_fields.include?(k)
            elem[k] = ERB.new(v.to_s).result(binding)
          end
        end
      end

      # Step 1.3: Validate and normalize `name`, `src`, `dst`, `fs_maps`, `perms`.
      if selected
        unless elem.has_key?(:src)
          error("Element `#{elem_identifier}` doesn't contain `src`.")
        end
        elem[:name] = elem[:src] unless elem.has_key?(:name)
        unless elem.has_key?(:dst)
          error("Element `#{elem_identifier}` doesn't contain `dst`.")
        end
	if elem.has_key?(:perms)
	  elem[:perms] = elem[:perms].to_s
	end
        elem[:fs_maps] = []
      end

      selected ? elem : nil
    end.compact

    # Step 1.4: For each active elem, match the `src` field against the
    #           filesystem and determine filesystem mapping (`fs_maps`).
    meta[:elems].each do |elem|
      found = false

      Find.find(elems_base_path)
          .select { |ebp| File.file?(ebp) }
          .each do |subfile_path|

        subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
                           Pathname.new(elems_base_path).join("elems")).to_s
        if md = Regexp.new(elem[:src]).match(subfile_rel_path.gsub(/\.tt$/, ''))
          found = true
          dst_path = elem[:dst].gsub(/<([0-9]+)>/) do
            idx = Integer($1)
            unless (1..md.length) === idx
              error("Invalid `dst` for element `#{elem[:name]}`: nothing " +
                    "captured at index `#{idx}`.")
            else
              md[idx]
            end
          end
          elem[:fs_maps] << {
            src_path: Pathname.new(subfile_path).expand_path,
            dst_path: Pathname.new(dst_path).expand_path
          }
        end
      end

      unless found
        warning("Inconsistency found for elem `#{elem[:name]}`: no file " +
                "matches src: `#{elem[:src]}`.")
      end
    end

    # ──────────────────────────────────────────────────────────────────────────
    # ☞ Step 2: Normalize commands

    command_excluded_erb_fields = [:only]

    meta[:commands] = [] unless meta.has_key?(:commands)

    meta[:commands] = meta[:commands].each_with_index.collect do |spec, idx|
      spec[:type] = spec[:type].to_sym
      spec[:name] ||= "type = #{spec[:type]}, index = #{idx}"
      info("\nCommand: ", spec[:name]) if verbose

      selected = selected_by_only?(spec[:only], verbose)

      if selected

        # Step 2.2: Pre-process strings with ERB.
        spec.each do |key, value|
          unless command_excluded_erb_fields.include?(key)
            if value.is_a?(String)
              spec[key] = ERB.new(value).result(binding)
            end
          end
        end

        # Step 2.3: Validate `type`, `validator`, `executor`.
        if !spec.has_key?(:type) ||
           !available_commands.keys.include?(spec[:type])
          error("The command `#{spec[:name]}` has invalid `type`: it's " +
                "not in `#{available_commands.keys}`.")
        end
        command = available_commands[spec[:type]]
        if command.has_key?(:validator) && !command[:validator].is_a?(Proc)
          error("Invalid validator for command `#{spec[:name]}`: if " +
                "provided it should be a `Proc`.")
        end
        if !command.has_key?(:executor) || !command[:executor].is_a?(Proc)
          error("Invalid executor for command `#{spec[:name]}`: it should " +
                "be a `Proc`.")
        end

        # Step 2.4: Use type-specific validator if it's defined.
        if command.has_key?(:validator) && (
             !command[:validator].is_a?(Proc) ||
             !command[:validator].call(spec)
           )
          error("The validator for command `#{spec[:name]}` didn't pass.")
        end
      end

      selected ? spec : nil
    end.compact

    # ──────────────────────────────────────────────────────────────────────────

    # Build the list of excluded files (needed by thor's `directory(..)`).
    all_files = Set.new(Find.find(elems_base_path)
                            .map{|f| Pathname.new(f).expand_path}
                            .select{|f| f.file?})
    src_paths = Set.new(
      meta[:elems].collect_concat do |elem|
        elem[:fs_maps].map{|m| m[:src_path]}
      end)
    vars_files = Pathname.glob(vars_path.join("*"), File::FNM_DOTMATCH)
    meta[:system_files]    = Set.new(vars_files << meta_path)
    meta[:excluded_files]  = all_files - src_paths - meta[:system_files]
    meta[:all_files_count] = all_files.count

    meta
  end

  # Return whether the provided `only` specification is evaluated as an allow
  # (and not as a deny).
  #
  def selected_by_only?(only, verbose)
    selected = if only.is_a?(Hash) # Evaluate `only` has a Hash.
      wants_features = only.has_key?(:features)
      wants_vars     = only.has_key?(:vars)
      if wants_features
        feat_ok = only[:features].any? do |feature|
          case feature
            when Array then feature.all?{|f| has_feature?(f)}
            else            has_feature?(feature)
          end
        end
      else
        feat_ok = true
      end
      vars_ok = wants_vars ?
          only[:vars].any?{|var| !get_var(var, single_match: false).nil?} :
          true

      (!wants_features && !wants_vars) || (feat_ok && vars_ok)
    elsif only.is_a?(String) # Evaluate `only` has a logic expression.
      Fizzy::LogicParser.new.parse(self, only)
    elsif only.nil? # By default, it's selected.
      selected = true
    else
      error("`#{spec[:name]}` has invalid `only`.")
    end

    if verbose
      if selected
        if only.nil?
          info(" ↳ ", "#{✔} (`only` is empty).")
        else
          info(" ↳ ", "#{✔} (`only` is present and satisfied).")
        end
      else
        info(" ↳ ", "#{✘} (`only` didn't match).")
      end
    end

    selected
  end

end

# ────────────────────────────────────────────────────── Meta elements ← Core ──

# Manage elements declared in the meta file.
#
module Fizzy::MetaElements

  include Fizzy::IO
  include Fizzy::Execution

  # Return a list of functions capable to apply modifications on the system
  # based on the current elements configuration instance.
  #
  # In particular, an applier work for each element installed.
  #
  def elements_appliers
    [ lambda { |elem| # Create parent directories.
        elem[:fs_maps].each do |m|
          parent_dir = m[:dst_path].dirname
          unless parent_dir.directory?
            exec_cmd("mkdir -p #{parent_dir.shell_escape}",
                     as_su: !existing_dir(parent_dir))
          end
        end
      },
      lambda { |elem| # Create a symlink for each elements' `src_path`.
        elem[:fs_maps].each do |m|
          tell("  #{m[:src_path]} ← #{m[:dst_path]}") if @verbose
          cmd = "ln -s"
          should_link = if m[:dst_path].file?
            if m[:dst_path].realpath != m[:src_path]
              cmd << " -f"
              quiz("The destination file `#{m[:dst_path]}` already " +
                   "exists. Overwrite")
            else
              false
            end
          elsif m[:dst_path].directory?
            if quiz("The destination file `#{m[:dst_path]}` is a " +
                    "directory. Delete it")
              exec_cmd("rm -Rf #{m[:dst_path]}",
                       as_su: !existing_dir(m[:dst_path].dirname))
            end
          else
            # Link does not exist yet.
            true
          end

          if should_link
            cmd << " #{m[:src_path].shell_escape}"
            cmd << " #{m[:dst_path].shell_escape}"
            exec_cmd(cmd, as_su: !existing_dir(m[:dst_path].dirname))
          end
        end
      },
      lambda { |elem| # Change perms of the instantiated files (if specified).
        if elem.has_key?(:perms)
          elem[:fs_maps].each do |m|
            tell("Changing permissions of #{m[:src_path]} to " +
                 elem[:perms]) if @verbose
            exec_cmd("chmod -R #{elem[:perms].shell_escape} " +
                     m[:src_path].shell_escape,
                     as_su: !File.owned?(m[:src_path]))
          end
        end
      }
    ]
  end

end

# ──────────────────────────────────────────────────────── Base ← Sync ← Core ──

module Fizzy::Sync

  class << self
    include Fizzy::IO
  end

  def self.available
    [ Fizzy::Sync::Local,
      Fizzy::Sync::Git
    ]
  end

  def self.others(subject)
    subject = subject.class unless subject.is_a?(Class)
    result  = available
    result.delete(subject)
    result
  end

  def self.enabled(local_dir_path, remote_url)
    available.map    { |e| e.new(local_dir_path, remote_url) }.
              select { |e| e.enabled? }
  end

  def self.selected(local_dir_path, remote_url)
    enabled(local_dir_path, remote_url).last
  end

  def self.perform(local_dir_path, remote_url)
    synchronizer = selected(local_dir_path, remote_url)
    tell("Using synchronizer: `#{colorize(synchronizer.name, :magenta)}`", :cyan)

    status   = true
    status &&= synchronizer.update_remote if synchronizer.local_changed?
    status &&= synchronizer.update_local  if synchronizer.remote_changed?
    status
  end
end

class Fizzy::Sync::Base

  include Fizzy::IO

  attr_reader :name

  def initialize(name, local_dir_path, remote_url)
    must "synchronizer name",    name,           be: :not_nil
    must "local directory path", local_dir_path, be: Pathname

    @name           = name
    @local_dir_path = local_dir_path
    @remote_url     = remote_url
  end

  # Check if the current synchronizer is enabled.
  #
  # Note: inheritors should call the `super` method.
  #
  # Example:
  #
  #   def enabled?
  #     my_policy || super
  #   end
  #
  def enabled?
    return false if !@remote_url.nil? &&
                    Fizzy::Sync.others(self).any? { |e|
                      @remote_url.to_s.start_with?("#{e.name}:")
                    }
    return true if default? && Fizzy::Sync.others(self).
      map  { |e| e.new(@local_dir_path, @remote_url) }.
      all? { |e| !e.enabled? }
  end

  # Check if the current synchronizer is the default synchronizer.
  #
  def default?
    self.class == Fizzy::Sync.available.last
  end

  # Update local from the remote.
  #
  abstract_method :update_local

  # Update remote from local.
  #
  abstract_method :update_remote

  # Check if local is changed, and now is different from latest remote state.
  #
  abstract_method :local_changed?

  # Check if remote is changed, and now is different from latest local state.
  #
  abstract_method :remote_changed?

end

# ─────────────────────────────────────────────────────── Local ← Sync ← Core ──

class Fizzy::Sync::Local < Fizzy::Sync::Base

  def initialize(local_dir_path, remote_url)
    super(:local, local_dir_path, remote_url)
    @remote_path = @remote_url.nil? ? nil : Pathname.new(@remote_url)
  end

  # Check if the synchronizer is enabled.
  #
  def enabled?
      ( super ||
        !@remote_path.nil? && @remote_path.directory? ||
        local_valid_repo?)
  end

  # Update local from the remote.
  #
  def update_local
    # TODO
  end

  # Update remote from local.
  #
  def update_remote
    # TODO
  end

  # Check if local is changed, and now is different from latest remote state.
  #
  def local_changed?
    # TODO
  end

  # Check if remote is changed, and now is different from latest local state.
  #
  def remote_changed?
    # TODO
  end

  # Check if the local directory holds a valid local repository.
  #
  def local_valid_repo?
    @local_dir_path.directory?
  end

end

# ───────────────────────────────────────────────────────── Git ← Sync ← Core ──

class Fizzy::Sync::Git < Fizzy::Sync::Base

  include Fizzy::IO
  include Fizzy::Execution
  include Fizzy::Filesystem

  def initialize(local_dir_path, remote_url)
    super(:git, local_dir_path, remote_url)
    @remote_normalized_url = normalize_url(@remote_url)
  end

  # Check if the synchronizer is enabled.
  #
  def enabled?
    ( super ||
      (!@remote_url.nil? && @remote_url.to_s.start_with?("#{@name}:")) ||
      local_valid_repo?)
  end

  # Update local from remote.
  #
  def update_local
    if local_valid_repo?
      # Update existing local from remote, i.e. perform `git pull`.
      tell "Syncing from `origin` to local", :blue
      status   = perform_commit
      status &&= perform_pull
    else
      # Update non-existing local from remote, i.e. perform `git clone`.
      perform_clone
    end
  end

  # Update remote from local.
  #
  def update_remote
    tell "Syncing from local to `origin`", :blue
    status   = perform_commit
    status &&= perform_push
  end

  # Check if local is changed, and now is different from latest remote state.
  #
  def local_changed?
    tell "Checking if local repository is changed", :blue
    return false unless local_valid_repo?
    return true  if     working_tree_changes?
    return true  if     perform_fetch && should_push?
    false
  end

  # Check if remote is changed, and now is different from latest local state.
  #
  def remote_changed?
    tell "Checking if remote repository is changed", :blue
    return true unless local_valid_repo?
    return true if     perform_fetch && should_pull?
    false
  end

protected

  # Normalize the remote git URL.
  #
  def normalize_url(url, default_protocol: :ssh)
    return nil if url.nil?
    url = url.to_s
    protocols = %i(https ssh)
    url = url.gsub(/^#{@name}:/, "") # Remove VCS name prefix (optional).
    regexp = %r{
      ^
      (?<protocol>#{protocols.map{|p| "#{p}:"}.join("|")})?
      (?<username>[a-z0-9\-_]+)
      \/
      (?<repository>[a-z0-9\-_]+)
      $
    }xi
    md = url.match(regexp)
    return url unless md
    protocol = (md[:protocol].gsub(/:$/, "") || default_protocol).to_sym
    case protocol
      when :ssh   then "git@github.com:#{md[:username]}/#{md[:repository]}"
      when :https then "https://github.com/#{md[:username]}/#{md[:repository]}"
      else        error("Invalid protocol for `#{url}`: `#{protocol}` not in " +
                        "`[#{protocols.join(", ")}]`.")
    end
  end

  # Check if the local directory holds a valid git repository.
  #
  def local_valid_repo?
    @local_dir_path.directory? && @local_dir_path.join(".git").directory?
  end

  # Get the Working Tree (local) changes.
  #
  def working_tree_changes
    error "Invalid local repo: `#{@local_dir_path}`" unless local_valid_repo?
    FileUtils.cd(@local_dir_path) do
      return `git status -uall --porcelain`.strip
    end
  end

  # Check if there are some changes in the Working Tree.
  #
  def working_tree_changes?
    !working_tree_changes.empty?
  end

  # Get a `Hash` containing information about the local and remote repository.
  #
  def info
    error "Invalid local repo: `#{@local_dir_path}`" unless local_valid_repo?
    FileUtils.cd(@local_dir_path) do
      local = `git rev-parse @ 2> /dev/null`.strip
      local = nil unless $?.success?
      remote = `git rev-parse @{u} 2> /dev/null`.strip
      remote = nil unless $?.success?
      base = `git merge-base @ @{u} 2> /dev/null`.strip
      base = nil unless $?.success?
      return { local: local, remote: remote, base: base }
    end
  end

  # Check if a `pull` operation is needed.
  #
  def should_pull?
    info[:remote] != info[:base]
  end

  # Check if a `push` operation is needed.
  #
  def should_push?
    info[:local] != info[:base]
  end

  # Get the list of the available remote git repositories.
  #
  def remotes
    error "Invalid local repo: `#{@local_dir_path}`" unless local_valid_repo?
    FileUtils.cd(@local_dir_path) do
      return `git remote`.split(/\W+/).reject(&:empty?)
    end
  end

  # Get the list of the available git branches.
  #
  def branches
    error "Invalid local repo: `#{@local_dir_path}`" unless local_valid_repo?
    FileUtils.cd(@local_dir_path) do
      return `git branch`.split(/\W+/).reject(&:empty?)
    end
  end

  # Add the changes from the Working Tree to the stage.
  #
  def perform_add(files: nil, interactive: false)
    error "Invalid files `#{files}`." unless files.nil? || files.is_a?(Array)

    cmd  = ["git", "add"]
    cmd << "-i"  if     interactive
    cmd << "-A"  if     files.nil?
    cmd << files unless files.nil?

    error("Invalid local repo: `#{@local_dir_path}`") unless local_valid_repo?
    exec_cmd(cmd, as_su: !existing_dir(@local_dir_path), chdir: @local_dir_path)
  end

  # Commit the changes in the Working Tree.
  #
  def perform_commit(message: nil)
    status = true

    if working_tree_changes?
      tell "The configuration has the following local changes:\n" +
           "#{colorize(working_tree_changes, :white)}", :cyan
      if message || quiz("Do you want to commit them all")
        status &&= perform_add # Add from Working Tree to stage.
        if status
          tell("Performing commit", :blue)

          message ||= quiz("Type the commit message", type: :string)

          cmd  = ["git", "commit", "-a"]
          cmd << "--allow-empty-message" if     message.nil?
          cmd += ["-m", message]         unless message.nil?

          error "Invalid local repo: `#{@local_dir_path}`" unless local_valid_repo?
          status &&= exec_cmd(cmd,
                              as_su: !existing_dir(@local_dir_path),
                              chdir: @local_dir_path)
        end
      end
    end

    status
  end

  def perform_fetch(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`.") if remote && !remotes.include?(remote)
    error("Invalid branch `#{branch}`.") if branch && !branches.include?(branch)

    tell("Fetching information from remote", :blue)

    cmd  = ["git", "fetch"]
    cmd << remote.shell_escape unless remote.nil?
    cmd << branch.shell_escape unless branch.nil?

    error("Invalid local repo: `#{@local_dir_path}`") unless local_valid_repo?
    exec_cmd(cmd, as_su: !existing_dir(@local_dir_path), chdir: @local_dir_path)
  end

  def perform_clone(recursive: true)
    tell("Syncing from remote repository: `#{@remote_normalized_url}`", :blue)
    error("Invalid url: can't be empty.") if @remote_normalized_url.nil?

    parent_dir = @local_dir_path.dirname
    name       = @local_dir_path.basename

    cmd  = ["git", "clone"]
    cmd << "--recursive" if recursive
    cmd << @remote_normalized_url.shell_escape
    cmd << name.shell_escape

    exec_cmd(cmd, as_su: !existing_dir(parent_dir), chdir: parent_dir)
  end

  # Pull from the provided `remote` in the provided `branch`.
  #
  def perform_pull(remote: nil, branch: nil, with_submodules: true)
    error("Invalid remote `#{remote}`") if remote && !remotes.include?(remote)
    error("Invalid branch `#{branch}`") if branch && !branches.include?(branch)

    status = true

    if should_pull?
      tell("Performing pull", :blue)

      cmd  = ["git", "pull"]
      cmd << remote.shell_escape unless remote.nil?
      cmd << branch.shell_escape unless branch.nil?

      error("Invalid local repo: `#{@local_dir_path}`") unless local_valid_repo?
      status = exec_cmd(cmd,
                        as_su: !existing_dir(@local_dir_path),
                        chdir: @local_dir_path)

      if with_submodules
        status &&= exec_cmd(%w(git submodule update --recursive),
                            as_su: !existing_dir(@local_dir_path),
                            chdir: @local_dir_path)
      end
    end

    status
  end

  # Push to the provided `remote` in the provided `branch`.
  #
  def perform_push(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`") if remote && !remotes.include?(remote)
    error("Invalid branch `#{branch}`") if branch && !branches.include?(branch)

    status = true

    if should_push?
      tell("Pushing to remote", :blue)

      cmd  = ["git", "push"]
      cmd << remote.shell_escape unless remote.nil?
      cmd << branch.shell_escape unless branch.nil?

      error("Invalid local repo: `#{@local_dir_path}`") unless local_valid_repo?
      status &&= exec_cmd(cmd,
                          as_su: !existing_dir(@local_dir_path),
                          chdir: @local_dir_path)
    end

    status
  end

end

# ────────────────────────────────────────────────── Lastpass ← Filters ← Lib ──

Fizzy::Vars::Filters.define(:lpass, description: """
LastPass filter allows to retrieve informations stored in a lastpass account
As arguments you can pass:
- #0: A unique name or identifier of the element to be retrieved.
- #1 [optional]: What information should be retrieved from the element.
                 Defaults to the element's password.
""") do |args|
  args = args.split_by_separator
  name = args[0].shell_escape
  what = args[1] || :password
  what = "--#{what}" unless what.to_s.start_with?("--")
  `lpass show --color=never #{what} #{name}`
end

# ─────────────────────────────────────────────────────────── Base ← Commands ──

# Base class for all fizzy commands.
#
class Fizzy::BaseCommand < Thor

  include Thor::Actions

  include Fizzy::Environment
  include Fizzy::Execution
  include Fizzy::Filesystem
  include Fizzy::IO
  include Fizzy::Vars
  include Fizzy::Locals
  include Fizzy::MetaInfo
  include Fizzy::MetaElements
  include Fizzy::MetaCommands

  # Common options, shared by many commands.
  #
  SHARED_OPTIONS = {
    verbose: {
      default: false,
      type:    :boolean,
      aliases: :v,
      desc:    "Whether the output should be verbose."
    },
    run_mode: {
      default: "normal",
      aliases: :R,
      enum:    %w(normal paranoid dry),
      desc:    "Ask confirmation for each filesystem operation."
    },
    fizzy_dir: {
      default: Fizzy::CFG.default_fizzy_dir,
      aliases: :F,
      desc:    "The root path for the directory internally used by fizzy."
    },
    cfg_url: {
      default: nil,
      aliases: :U,
      desc: "The URL to the repository holding config."
    },
    cfg_name: {
      default: nil,
      aliases: :C,
      desc:    "The name of the configuration that should be used."
    },
    inst_name: {
      default: nil,
      aliases: :I,
      desc:    "The name for the configuration instance to be used."
    },
    vars_name: {
      default: nil,
      aliases: :V,
      desc:    "The name for the variables file to be used."
    },
    meta_name: {
      default: Fizzy::CFG.default_meta_name,
      aliases: :M,
      desc:    "The name of the meta file."
    }
  }

  class << self

    include Fizzy::IO

    # @return a shared option.
    #
    def shared_option(name, required: false)
      args = SHARED_OPTIONS[name].dup
      error("Invalid option `#{name}`: it doesn't exist.") if args.nil?

      if required
        args.delete(:default)
        args[:required] = true
      elsif !args.has_key?(:default)
        error("Invalid shared option `#{name}`: doesn't have a default value.")
      end

      [name, args]
    end

  end

end

# ──────────────────────────────────────────────────────────── Cfg ← Commands ──

class Fizzy::CfgCommand < Fizzy::BaseCommand

  def self.source_root
    "/"
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  desc("details", "Show configuration details.")
  def details
    # Prepare paths before considering details.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_cfg:    :readonly,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name)
    # Print details.
    tell("Available variable files:", :cyan)
    avail_vars(paths.cur_cfg_vars).each do |path|
      name = path.basename(path.extname)
      tell("\t→ #{colorize(name, :magenta)}")
    end
  end

  method_option(*shared_option(:fizzy_dir))
  desc("cleanup", "Cleanup the fizzy storage.")
  def cleanup
    # Prepare paths for cleanup.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta: false,
                            valid_cfg:  false,
                            valid_inst: false)

    # Perform cleanup.
    status = if quiz("Remove the fizzy root directory (`#{paths.root}`)")
      paths.root.rmtree
    else
      nil # Cleanup skipped.
    end

    # Inform user about the cleanup status.
    case status
      when true  then tell("Successfully cleaned: `#{paths.root}`.", :green)
      when false then error("Failed to cleanup: `#{paths.root}`.", :red)
      when nil   then warning("Cleanup skipped.", ask_continue: false)
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc("cd",
       "Change directory to the configuration directory " +
       "(useful for extensive filesystem manipulations).")
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            valid_cfg:    !options.cfg_name.nil?,
                            cur_cfg_name: options.cfg_name)

    # Changing directory.
    dir_path = paths.cur_cfg || paths.cfg
    tell("Changing directory to: `#{dir_path}`.", :cyan)
    FileUtils.cd(dir_path)
    system(get_env!(:SHELL))

    # Inform user about the changing directory status.
    tell("CD done in: `#{dir_path}`.", :green)
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc("edit PATTERN", "Find the files relative to PATTERN and edit them.")
  def edit(pattern)
    # Prepare stuff for editing.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name)
    find_path = (paths.cur_cfg || paths.cfg).join(pattern)
    cfg_files = if find_path.exist?
      Array[find_path]
    else
      Pathname.glob("#{find_path}*", File::FNM_DOTMATCH).to_a
              .select(&:file?)
              .reject{|path| path.to_s =~ /\.git/}
    end

    cfg_files_arg = cfg_files.collect{|path| path.shell_escape}
                             .join(" ")
                             .strip

    # Perform edit.
    status = if cfg_files_arg.empty?
      warning("No files matching `#{options.cfg_name}` have been found.",
              ask_continue: false)
      nil
    else
      tell("Editing configuration file(s): `#{cfg_files_arg}`.", :cyan)
      system("#{Fizzy::CFG.editor} #{cfg_files_arg}")
    end

    # Inform user about the editing status.
    case status
      when true  then tell("Successfully edited: `#{cfg_files_arg}`.", :green)
      when false then error("Failed to edit: `#{cfg_files_arg}`.", :red)
      when nil   then warning("Editing skipped.", ask_continue: false)
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name, required: true))
  method_option(*shared_option(:cfg_url))
  desc("sync", "Synchronize the remote repository with the local one.")
  def sync
    # Prepare stuff for syncing.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_cfg:    false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name)

    # Perform sync.
    sync_result = Fizzy::Sync.perform(paths.cur_cfg, options.cfg_url)

    # Inform user about sync status.
    if sync_result
      tell("Synced to: `#{paths.cur_cfg}`.", :green)
    else
      error("Unable to sync.")
    end
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("instantiate", "Create a configuration instance in the current machine.")
  def instantiate
    # Before instantiation.
    paths = prepare_storage(options.fizzy_dir,
                            meta_name:     options.meta_name,
                            valid_cfg:     :readonly,
                            valid_inst:    false,
                            cur_cfg_name:  options.cfg_name,
                            cur_inst_name: options.inst_name)
    setup_vars(paths.cur_cfg_vars, options.vars_name)

    meta = get_meta(paths.cur_cfg_meta, paths.cur_cfg_vars, paths.cur_cfg,
                    options.verbose)

    info("meta: ", "#{colorize(meta[:elems].count, :green)}/" +
                   "#{meta[:all_elems_count]} elem(s) selected.")
    info("meta: ", "#{colorize(meta[:excluded_files].count, :red)}/" +
                   "#{meta[:all_files_count]} file(s) excluded.")
    tell

    # Create a configuration instance.
    tell("Creating a configuration instance named `#{options.inst_name}` " +
         "from: `#{paths.cur_cfg}`.", :blue)

    exclude_pattern = Fizzy::CFG.instantiate_exclude_pattern
    meta[:excluded_files].each do |excluded_file|
      exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
    end

    begin
      directory(paths.cur_cfg, paths.cur_inst, exclude_pattern: exclude_pattern)
    rescue SyntaxError
      error("Error while processing the template: `#{$fizzy_cur_template}`.")
    end

    # After instantiation.
    tell("Created the configuration instance in: `#{paths.cur_inst}`.", :green)
  end

end

# ─────────────────────────────────────────────────────────── Inst ← Commands ──

class Fizzy::InstCommand < Fizzy::BaseCommand

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name))
  desc("cd", "Change directory to the instance directory " +
             "(useful for extensive filesystem manipulations).")
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:    false,
                            valid_cfg:     false,
                            valid_inst:    !options.inst_name.nil?,
                            cur_inst_name: options.inst_name)

    # Changing directory.
    dir_path = paths.cur_inst || paths.inst
    tell("Changing directory to: `#{dir_path}`.", :cyan)
    FileUtils.cd(dir_path)
    system get_env!(:SHELL)

    # Inform user about the changing directory status.
    tell("CD done in: `#{dir_path}`.", :green)
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("install", "Install the current configuration instance in the system.")
  def install
    # Prepare stuff for performing install.
    @run_mode = options.run_mode.to_sym
    @verbose  = options.verbose
    paths = prepare_storage(options.fizzy_dir,
                            valid_cfg:     false,
                            meta_name:     options.meta_name,
                            cur_inst_name: options.inst_name)
    setup_vars(paths.cur_inst_vars, options.vars_name)

    meta = get_meta(paths.cur_inst_meta, paths.cur_inst_vars, paths.cur_inst,
                    options.verbose)

    # 1. Install the instance into the system.
    tell("Installing the configuration instance `#{options.inst_name}` " +
         "into the system.", :blue)
    # 1.1 Install the elements.
    meta[:elems].each do |elem|
      tell("Installing element: `#{elem[:name]}`.", :cyan)
      elements_appliers.each { |applier| applier.call(elem) }
      if elem[:notes]
        tell("Notes for `#{elem[:name]}`:", :yellow)
        tell(elem[:notes].split("\n").collect { |s| "  #{s}" }.join("\n"))
      end
    end
    # 1.2 Install the commands.
    meta[:commands].each do |spec|
      tell("Executing command: `#{spec[:name]}`.", :cyan)
      available_commands[spec[:type]][:executor].call(spec)
    end

    # Inform the user about installation status.
    tell("The configuration instance `#{options.inst_name}` has been " +
         "installed into the system", :green)
  end

end

# ─────────────────────────────────────────────────────────── Main ← Commands ──

class Fizzy::MainCommand < Fizzy::BaseCommand

  desc("cfg SUBCOMMAND ...ARGS", "Manage the fizzy configuration " +
                                 "(without modifying the host system).")
  subcommand("cfg", Fizzy::CfgCommand)

  desc("inst SUBCOMMAND ...ARGS", "Manage a configuration instance")
  subcommand("inst", Fizzy::InstCommand)

  desc("usage", "Show how to use fizzy.")
  def usage
    url = URI.join(Fizzy::CFG.static_files_base_url, "README.md")
    res = Net::HTTP.get_response(url)
    if res.is_a?(Net::HTTPSuccess)
      tell("\n#{res.body}\n")
    else
      error("Network error: cannot retrieve `#{url}`.")
    end
  end

  desc("version", "Show fizzy version.")
  def version
    info "fizzy version", Fizzy::CFG.version
    info "ruby version", "ruby #{RUBY_VERSION}p#{RUBY_PATCHLEVEL}"
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("quick-install", "Quickly install a configuration.")
  def quick_install
    invoke(Fizzy::CfgCommand, "instantiate", [],
           cfg_name:  options.cfg_name,
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           verbose:   options.verbose)
    invoke(Fizzy::InstCommand, "install", [],
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           run_mode:  options.run_mode,
           verbose:   options.verbose)
  end
  map :qi => :quick_install

end

# ────────────────────────────────────────────────────────────────────── Main ──

# Entry point.
Fizzy::MainCommand.start(ARGV) if $0 == __FILE__

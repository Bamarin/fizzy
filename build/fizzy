#!/usr/bin/env ruby

# File header ─────────────────────────────────────────────────────────────────┐
#                                                                              │
# File informations:                                                           │
# - Name:    fizzy                                                             │
# - Summary: The hassle free configuration manager                             │
# - Authors:                                                                   │
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)              │
# - Contributors:                                                              │
#   - Luca Molari <molari.luca@gmail.com> (lmolr)                              │
#   Special thanks:                                                            │
#   - Thor project (https://github.com/erikhuda/thor)                          │
#   - Hash#deep_merge (http://www.ruby-forum.com/topic/142809)                 │
#                                                                              │
#                                                                              │
# Project informations:                                                        │
#   - Homepage:        https://github.com/alem0lars/fizzy                      │
#   - Getting started: see README.md in the project root folder                │
#                                                                              │
# License: Apache v2.0 (see below)                                             │
#                                                                              │
# ─────────────────────────────────────────────────────────────────────────────┤
#                                                                              │
# Licensed to the Apache Software Foundation (ASF) under one more contributor  │
# license agreements.  See the NOTICE file distributed with this work for      │
# additional information regarding copyright ownership. The ASF licenses this  │
# file to you under the Apache License, Version 2.0 (the "License"); you may   │
# not use this file except in compliance with the License.                     │
# You may obtain a copy of the License at                                      │
#                                                                              │
#   http://www.apache.org/licenses/LICENSE-2.0                                 │
#                                                                              │
# Unless required by applicable law or agreed to in writing, software          │
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT    │
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.             │
# See the License for the specific language governing permissions and          │
# limitations under the License.                                               │
#                                                                              │
# ─────────────────────────────────────────────────────────────────────────────┘


# ☞ Requires ───────────────────────────────────────────────────────────────────

# Core modules.
require "fileutils"
require "find"
require "json"
require "net/http"
require "ostruct"
require "pathname"
require "securerandom"
require "shellwords"
require "strscan"
require "uri"
require "yaml"

# Try to require `thor` or raise an exception.
begin
  require "thor"
rescue
  puts("\e[31m☠ The gem `thor` is not installed. " +
       "To install run: `gem install thor`. Aborting.\e[0m")
  exit(-1)
end

# Top-level namespace.
module Fizzy
end

# ☞ Configuration ──────────────────────────────────────────────────────────────

Fizzy::CFG = OpenStruct.new

# URL for reporting fizzy issues.
Fizzy::CFG.issues_url = "https://github.com/alem0lars/fizzy/issues"

# Default editor.
Fizzy::CFG.editor = ENV["EDITOR"] || "vim"

# Debug mode.
Fizzy::CFG.debug = ENV["FIZZY_DEBUG"] =~ /^(?:true|yes)$/

# The operating-system which fizzy is running on.
Fizzy::CFG.os = case RUBY_PLATFORM
                when /darwin/ then :osx
                when /linux/  then :linux
                else               :windows
                end

# Remote URL for fizzy static files (must end with a slash).
Fizzy::CFG.static_files_base_url =
  URI("https://raw.githubusercontent.com/alem0lars/fizzy/master/")

# Default fizzy root directory (holding all of the fizzy stuff).
Fizzy::CFG.default_fizzy_dir = Pathname.new(
  ENV["FIZZY_DIR"] ||
  case Fizzy::CFG.os
  when :linux   then "/usr/share/fizzy"
  when :osx     then "~/Library/Application Support/fizzy"
  when :windows then "~/fizzy"
  end
).expand_path

# Default meta file name.
Fizzy::CFG.default_meta_name = "meta.yml"

# ☞ Exts → Hash ────────────────────────────────────────────────────────────────

class Hash

  # Perform recursive merge of the current `Hash` (`self`) with the provided one
  # (the `second` argument).
  #
  # The merge have knows how to recurse in both `Hash`es and `Array`s.
  #
  def deep_merge(second)
    merger = proc do |key, v1, v2|
      if Hash === v1 && Hash === v2
        v1.merge(v2, &merger)
      elsif Array === v1 && Array === v2
        (Set.new(v1) + Set.new(v2)).to_a
      else
        v2
      end
    end
    self.merge(second, &merger)
  end

  def fqkeys(prefix="")
    self.inject([]) do |acc, (k, v)|
      prefix_new = prefix.empty? ? k.to_s : "#{prefix}.#{k}"
      acc + (v.is_a?(Hash) ? v.fqkeys(prefix_new) : [prefix_new])
    end
  end

  def slice(*keys)
    self.select{|k, _| keys.include?(k)}
  end

end

# ☞ Exts → Thor ────────────────────────────────────────────────────────────────

class Thor
  module Actions

    # Monkey-patch to retrieve the template currently processed.
    old_template = instance_method(:template)
    define_method :template, ->(source, *args, &blk) do
      $fizzy_cur_template = source
      old_template.bind(self).(source, *args, &blk)
    end

  end
end

# ☞ Utils → Io ─────────────────────────────────────────────────────────────────

module Fizzy::IO

  # Get the shell object.
  # It will be lazily instantiated.
  def shell
    @shell ||= Thor::Shell::Color.new
  end

  # Ask a question to the user.
  #
  # The message is made by the `question` string, with some additions (like
  # `?` sign).
  #
  # The available quiz types are:
  # - `:bool`: Boolean quiz, the user can respond with `yes` or `no` (or
  #            alternatives, see regexes below). A boolean value is returned.
  # - `:string`: Normal quiz, the user is prompt for a question and if the
  #              answer isn't empty is returned.
  #
  def quiz(question, type: :bool)
    answer = shell.ask("#{question.strip}? ", :magenta)
    case type
    when :bool
      if answer =~ /y|ye|yes|yeah|ofc/i
        true
      elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
        false
      else
        tell("Answer misunderstood", :yellow)
        quiz(question, type: type)
      end
    when :string
      if answer.empty?
        warning("Empty answer", ask_continue: false)
        quiz(question, type: type)
      else
        answer
      end
    else
      error("Unhandled question type: `#{type}`.")
    end
  end

  def debug(msg)
    caller_info = caller.
      map { |c| c[/`.*'/][1..-2].split(" ").first }.
      uniq[0..2].
      join(" → ")

    tell(colorize("⚫ ", :magenta) +
         colorize("<", :blue) +
         colorize(caller_info, :cyan) +
         colorize(">", :blue) +
         colorize(": #{msg}", :white)) if Fizzy::CFG.debug
  end

  # Display an informative message (`msg`) to the user.
  #
  # The `prefix` argument should contain some text displayed before the
  # message, typically to show the context which the message belongs to.
  #
  def info(prefix, msg)
    tell(colorize("☞ ", :magenta) +
         colorize(prefix, :cyan) +
         colorize(" #{msg}", :white))
  end

  # Display an informative message (`msg`) to the user.
  #
  # If `ask_continue` is `true`, the user can interactively choose to stop
  # the program or exit (with exit status `-1`).
  #
  def warning(msg, ask_continue: true)
    tell(colorize("☞ ", :magenta) + colorize(msg, :yellow))
    exit(-1) if ask_continue && !quiz("continue")
  end

  # Display an error message (`msg`) to the user. Before returning, the
  # program will exit (with exit status `-1`).
  #
  def error(msg, status: -1)
    error("Invalid status code `#{status}`: it's not negative") if status >= 0
    tell(colorize("☠ ", :magenta) + colorize(msg, :red))
    exit(status)
  end

  # Tell something to the user.
  # It's a proxy method to `Thor::Shell::Color.say`.
  #
  def tell(*args)
    shell.say(*args)
  end

  # Colorize the provided string.
  # It's a proxy method to `Thor::Shell::Color.set_color`.
  #
  def colorize(*args)
    shell.set_color(*args)
  end

end

# ☞ Grammars → Base Lexer ──────────────────────────────────────────────────────

class Fizzy::BaseLexer

  include Fizzy::IO

  def initialize(string)
    @base   = StringScanner.new(string)
    @rules  = []
    @tokens = []
  end

  def ignore(pattern)
    @rules << [pattern, [:SKIP]]
  end

  def tokens(pattern, *names)
    @rules << [pattern, names]
  end

  def token(pattern, name)
    @rules << [pattern, [name]]
  end

  def keyword(name)
    token(Regexp.new(name), name)
  end

  def next_token
    build_tokens if @tokens.empty?
    t = @tokens.shift
    t.first == :SKIP ? next_token : t
  end

private

  # (Re)build the list of tokens.
  # Every token is: `[value, token_name]`.
  def build_tokens
    @tokens = []
    @tokens += find_tokens until @base.empty?
    @tokens << [false, false] # Last token, meaning EOS.
    debug("Built tokens: `#{@tokens}`.")
  end

  def find_tokens
    @rules.each do |pattern, tokens|
      matched_substring = @base.scan(pattern)
      unless matched_substring.nil?
        if @base[1].nil? # No captures, return the matched string.
          error("Only one token, not `#{tokens.length}` (`#{tokens}`) should " +
                "be provided.") if tokens.length != 1
          return [[tokens.first, matched_substring]]
        else
          captures, base_idx = [], 0
          captures << @base[base_idx] until @base[base_idx += 1].nil?
          error("You need to provide `#{captures.length}` tokens, instead of " +
                "`#{tokens.length}`.") unless captures.length == tokens.length
          return tokens.zip(captures)
        end
      end
    end
    error("Unexpected characters.")
  end

end

# ☞ Lexer ──────────────────────────────────────────────────────────────────────

class Fizzy::LogicLexer < Fizzy::BaseLexer

  def initialize(string)
    super

    ignore(/\s+/)

    token(/=/,    :EQ)
    token(/&&/,   :AND)
    token(/\|\|/, :OR)
    token(/\(/,   :LBRACKET)
    token(/\)/,   :RBRACKET)

    tokens(/(f\?)(#{name_with("-_")})/,  :FEATURE_PREFIX, :FEATURE_NAME)
    tokens(/(v\?)(#{name_with("-_.")})/, :VAR_PREFIX,     :VAR_NAME)

    token(/.+/, :VALUE) # Anything that would otherwise not match is a value.
  end

private

  def name_with(symbols)
    /\w+(?:[#{symbols}]\w+)*/
  end

end

# ☞ Evaluator ──────────────────────────────────────────────────────────────────

class Fizzy::LogicEvaluator

  include Fizzy::IO

  attr_accessor :result

  def initialize(receiver)
    @receiver = receiver
    @result   = nil
  end

  def result=(other)
    @result = result
    debug("Initialized `result` to `#{other}`.")
  end

  def and(other)
    prev_result_value = @result
    @result &&= other
    debug("Performed logical `and` between previous value of result " +
          "(`#{prev_result_value}`) and `#{other}`: operation evaluated " +
          "to `#{@result}`.")
  end

  def or(other)
    prev_result_value = @result
    @result ||= other
    debug("Performed logical `or` between previous value of result " +
          "(`#{prev_result_value}`) and `#{other}`: operation evaluated " +
          "to `#{@result}`.")
  end

  def has_feature?(name)
    @result = @receiver.has_feature?(name)
    debug("Parsed feature `#{name}`: it's #{@result ? "" : "not "}available.")
  end

  def has_variable?(name)
    @result = !@receiver.get_var(name).nil?
    debug("Parsed variable `#{name}` with value " +
          "`#{@receiver.get_var(name)}`: " +
          "it's #{@result ? "" : "not "}available.")
  end

  def variable_value?(name, expected_value)
    @result = @receiver.get_var(name) == expected_value
    debug("Parsed variable `#{name}` with value " +
          "`#{@receiver.get_var(name)}`: " +
          "it's #{@result ? "" : "not "}equal to `#{expected_value}`.")
  end
end

# ☞ Logic Parser ───────────────────────────────────────────────────────────────

#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.14
# from Racc grammer file "".
#

require 'racc/parser.rb'
module Fizzy
  class LogicParser < Racc::Parser

module_eval(<<'...end parser.y/module_eval...', 'parser.y', 29)

  def parse(receiver, arg)
    @yydebug = Fizzy::CFG.debug
    @lexer   = Fizzy::LogicLexer.new(arg)
    @eval    = Fizzy::LogicEvaluator.new(receiver)
    do_parse
    @eval.result
  end

  def next_token
    @lexer.next_token
  end

# vim: set filetype=racc :
...end parser.y/module_eval...
##### State transition tables begin ###

racc_action_table = [
     3,     3,     4,     4,     5,     5,     3,     3,     4,     4,
     5,     5,     7,     8,    12,    15,     7,     8,    11,    10,
     6,    16,     7,    17 ]

racc_action_check = [
     0,     7,     0,     7,     0,     7,     8,     3,     8,     3,
     8,     3,     9,     9,     6,     9,     2,     2,     5,     4,
     1,    11,    14,    16 ]

racc_action_pointer = [
    -5,    20,    13,     2,    11,     8,    14,    -4,     1,     9,
   nil,    19,   nil,   nil,    19,   nil,    12,   nil ]

racc_action_default = [
    -8,    -8,    -1,    -8,    -8,    -8,    -8,    -8,    -8,    -8,
    -5,    -6,    18,    -3,    -4,    -2,    -8,    -7 ]

racc_goto_table = [
     2,     1,   nil,     9,   nil,   nil,   nil,    13,    14 ]

racc_goto_check = [
     2,     1,   nil,     2,   nil,   nil,   nil,     2,     2 ]

racc_goto_pointer = [
   nil,     1,     0 ]

racc_goto_default = [
   nil,   nil,   nil ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 13, :_reduce_none,
  3, 14, :_reduce_2,
  3, 14, :_reduce_3,
  3, 14, :_reduce_4,
  2, 14, :_reduce_5,
  2, 14, :_reduce_6,
  4, 14, :_reduce_7 ]

racc_reduce_n = 8

racc_shift_n = 18

racc_token_table = {
  false => 0,
  :error => 1,
  :EQ => 2,
  :AND => 3,
  :OR => 4,
  :LBRACKET => 5,
  :RBRACKET => 6,
  :FEATURE_PREFIX => 7,
  :FEATURE_NAME => 8,
  :VAR_PREFIX => 9,
  :VAR_NAME => 10,
  :VALUE => 11 }

racc_nt_base = 12

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "EQ",
  "AND",
  "OR",
  "LBRACKET",
  "RBRACKET",
  "FEATURE_PREFIX",
  "FEATURE_NAME",
  "VAR_PREFIX",
  "VAR_NAME",
  "VALUE",
  "$start",
  "target",
  "exp" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

module_eval(<<'.,.,', 'parser.y', 16)
  def _reduce_2(val, _values, result)
     @eval.result = val[1] 
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 18)
  def _reduce_3(val, _values, result)
     @eval.and(val[2]) 
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 19)
  def _reduce_4(val, _values, result)
     @eval.or(val[2])  
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 21)
  def _reduce_5(val, _values, result)
     @eval.has_feature?(val[1])            
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 22)
  def _reduce_6(val, _values, result)
     @eval.has_variable?(val[1])           
    result
  end
.,.,

module_eval(<<'.,.,', 'parser.y', 23)
  def _reduce_7(val, _values, result)
     @eval.variable_value?(val[1], val[3]) 
    result
  end
.,.,

def _reduce_none(val, _values, result)
  val[0]
end

  end   # class LogicParser
  end   # module Fizzy

# ☞ Utils → Environment ────────────────────────────────────────────────────────

# Utilities to retrieve informations about the host environment & system.
#
module Fizzy::Environment

  include Fizzy::IO

  # Return the environment variable matching the provided `name`.
  #
  def get_env(name, default: nil)
    ENV[name.to_s] || default
  end

  # Same of `get_env`, but raise an error if the environment variable hasn't
  # been found or is `nil`.
  #
  def get_env!(name)
    value = get_env(name)
    error("Undefined environment variable: `#{name}`.") if value.nil?
    value
  end

  # Check if the underlying operating system is MacOSX.
  #
  def is_osx?
    Fizzy::CFG.os == :osx
  end

  # Check if the underlying operating system is GNU/Linux.
  #
  def is_linux?
    Fizzy::CFG.os == :linux
  end

  # Check if the underlying operating system is Windows.
  #
  def is_windows?
    Fizzy::CFG.os == :windows
  end

  # Execute a function, based on the underlying operating system.
  #
  def case_os(osx: nil, linux: nil, windows: nil)
    if is_osx?
      osx.respond_to?(:call) ? osx.call : osx
    elsif is_linux?
      linux.respond_to?(:call) ? linux.call : linux
    elsif is_windows?
      windows.respond_to?(:call) ? windows.call : windows
    else
      error("Unrecognized operating system.")
    end
  end

end

# ☞ Utils → Execution ──────────────────────────────────────────────────────────

# Utilities to start and manage programs execution.
#
module Fizzy::Execution

  include Fizzy::IO

  # Execute the provided shell command (`cmd`).
  # If `as_su` is `true` the command is executed as super user
  # (i.e. as root, using sudo).
  #
  def exec_cmd(cmd, as_su: false)
    full_cmd = as_su ? "sudo #{cmd}" : cmd

    really_run = case @run_mode
                 when :normal
                   true
                 when :paranoid
                   quiz("Do you want to run command `#{full_cmd}`")
                 when :dry
                   false
                 else
                   true
                 end

    if really_run || @run_mode == :dry
      tell(as_su ? "[sudo] #{cmd}" : cmd, :magenta)
    end

    if really_run
      system(full_cmd) || warning("Command `#{full_cmd}` failed.")
    end
  end

end

# ☞ Utils → Filesystem ─────────────────────────────────────────────────────────

# Utilities to interact with the filesystem.
#
module Fizzy::Filesystem

  include Fizzy::IO
  include Fizzy::Execution

  # Find a YAML file prefixed by `path` (guess extension name).
  #
  def find_yaml_path(path)
    if path.file?
      path
    else
      %w(yml yaml).map do |ext|
        p = Pathname.new("#{path}.#{ext}")
        p if p.file?
      end.compact.first
    end
  end

  # Check if the provided `path` is an existing directory.
  #
  # If `writable` is true, also check if `path` points to a writable
  # directory.
  #
  def existing_dir(path, writable: true)
    dir_path = path
    dir_path = dir_path.dirname until dir_path.directory?
    (writable && !dir_path.writable?) ? nil : dir_path
  end

  # Return an object (`OpenStruct`), which contains all of the well-known
  # paths.
  #
  # Before adding a path, some validations are executed to ensure that path
  # points to a correct thing.
  #
  # You can skip some validations and filling some paths:
  # - `valid_cfg`:
  #   - If `false` don't validate and fill paths related to the configuration.
  #   - If `readonly`, don't validate writability for configuration.
  # - `valid_inst`:
  #   - If `false` don't validate and fill paths related to the configuration
  #     instances.
  #   - If `true`, be sure to provide the argument `cur_inst_name`, which
  #     should contain the name of the current instance (the instance that
  #     should be used).
  #   - If `readonly`, don't validate writability for instance.
  #
  def prepare_storage(root_path,
                      valid_meta: true, valid_cfg: true, valid_inst: true,
                      meta_name: nil, cur_cfg_name: nil, cur_inst_name: nil)
    root_path = Pathname.new(root_path).expand_path

    # Paths based on internal conventions.
    parent_path = root_path.dirname

    cfg_path = root_path.join("cfg")
    cur_cfg_path = cfg_path.join(cur_cfg_name) if cur_cfg_name
    cur_cfg_vars_path = cur_cfg_path.join("vars") if cur_cfg_path
    cur_cfg_meta_path = find_yaml_path(cur_cfg_path.join(meta_name)) if cur_cfg_path && meta_name

    inst_path = root_path.join("inst")
    cur_inst_path = inst_path.join(cur_inst_name) if cur_inst_name
    cur_inst_vars_path = cur_inst_path.join("vars") if cur_inst_path
    cur_inst_meta_path = find_yaml_path(cur_inst_path.join(meta_name)) if cur_inst_path && meta_name

    # Validate `root_path`.
    if !root_path.directory? && !parent_path.writable?
      error("Cannot create directory: `#{root_path}`.")
    end
    if root_path.file?
      if quiz("`#{root_path}` already exists but is a regular file. Remove")
        exec_cmd("rm #{Shellwords.escape(root_path)}",
                 as_su: File.owned?(root_path))
      else
        error("File `#{root_path}` already exists but is needed as fizzy " +
              "root directory. Aborting.")
      end
    end

    # XXX This check is for preventing errors when we don't want to create the
    #     directory structure. Should we add a dedicate argument?
    if !valid_cfg && !valid_inst && root_path.directory? && !root_path.writable?
      error("No write permissions in Fizzy storage at path `#{root_path}`.")
    end

    if valid_cfg
      unless root_path.directory?
        error("The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`).")
      end
      if cur_cfg_path.nil? || !cur_cfg_path.directory? || !(valid_cfg == :readonly || cur_cfg_path.writable?)
        error("The current configuration `#{cur_cfg_name}` is invalid: " +
              "it's not a valid directory.")
      end
      if valid_meta && (cur_cfg_meta_path.nil? || !cur_cfg_meta_path.file?)
        error("The meta file path `#{cur_cfg_meta_path}` is invalid.")
      end
      if cur_cfg_vars_path.nil? || !cur_cfg_vars_path.directory?
        error("The variables directory `#{cur_cfg_vars_path}` is invalid.")
      end
    end

    if valid_inst
      unless root_path.directory?
        error("The Fizzy root directory `#{root_path}` doesn't exist " +
              "(maybe you need to run: `fizzy cfg sync`).")
      end
      if cur_inst_path.nil? || !cur_inst_path.directory? || !(valid_inst == :readonly || cur_inst_path.writable?)
        error("The current instance `#{cur_inst_name}` is invalid: it's " +
              "not a valid directory.")
      end
      if valid_meta && (cur_inst_meta_path.nil? || !cur_inst_meta_path.file?)
        error("The meta file path `#{cur_inst_meta_path}` is invalid.")
      end
      if cur_inst_vars_path.nil? || !cur_inst_vars_path.directory?
        error("The variables directory `#{cur_inst_vars_path}` is invalid.")
      end
    end

    # Create non-existing internal directories.
    FileUtils.mkdir_p(root_path) unless root_path.directory?
    [cfg_path, inst_path].each do |dir_path|
      unless dir_path.directory?
        FileUtils.mkdir_p(dir_path)
        exec_cmd("chmod a+w #{Shellwords.escape(dir_path)}",
                 as_su: File.owned?(dir_path))
      end
    end
    if cur_inst_path && !cur_inst_path.directory?
      FileUtils.mkdir_p(cur_inst_path)
    end

    # Return the known storage paths.
    OpenStruct.new(
      root:          root_path,
      cfg:           cfg_path,
      cur_cfg:       cur_cfg_path,
      cur_cfg_vars:  cur_cfg_vars_path,
      cur_cfg_meta:  cur_cfg_meta_path,
      inst:          inst_path,
      cur_inst:      cur_inst_path,
      cur_inst_vars: cur_inst_vars_path,
      cur_inst_meta: cur_inst_meta_path)
  end

end

# ☞ Utils → Git ────────────────────────────────────────────────────────────────

module Fizzy::Git

  include Fizzy::IO
  include Fizzy::Execution
  include Fizzy::Filesystem

  def git_info(git_root_path)
    info = nil
    FileUtils.cd(git_root_path) do
      info = {
        local:  `git rev-parse @`.strip,
        remote: `git rev-parse @{u}`.strip,
        base:   `git merge-base @ @{u}`.strip
      }
    end
    info
  end

  def git_local_changes(git_root_path)
    `git status -uall --porcelain`.strip
  end

  def git_remotes
    `git remote`.split(/\W+/).reject(&:empty?)
  end

  def git_branches
    `git branch`.split(/\W+/).reject(&:empty?)
  end

  def git_has_local_changes(git_root_path)
    !git_local_changes(git_root_path).empty?
  end

  def git_should_pull(git_root_path)
    info = git_info(git_root_path)
    info[:remote] != info[:base]
  end

  def git_should_push(git_root_path)
    info = git_info(git_root_path)
    info[:local] != info[:base]
  end

  def git_pull(remote: nil, branch: nil, with_submodules: true)
    error("Invalid remote `#{remote}`.") \
      if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") \
      if branch && !git_branches.include?(branch)

    tell("Performing pull.", :blue)

    cmd  = "git pull"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    status   = exec_cmd(cmd, as_su: !existing_dir(Pathname.pwd))
    status &&= exec_cmd("git submodule update --recursive",
                        as_su: !existing_dir(Pathname.pwd)) if with_submodules

    status
  end

  def git_clone(url, dst_path, recursive: true)
    error("Invalid url: can't be empty.") if url.nil?
    url = git_normalize_url(url)
    tell("Syncing from remote repo: `#{url}`.", :blue)

    cmd  = "git clone"
    cmd << " --recursive" if recursive
    cmd << " #{Shellwords.escape(url)} #{Shellwords.escape(dst_path)}"

    exec_cmd(cmd, as_su: !existing_dir(dst_path.dirname))
  end

  def git_push(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`.") \
      if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") \
      if branch && !git_branches.include?(branch)

    tell("Pushing to remote.", :blue)

    cmd  = "git push"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    exec_cmd(cmd, as_su: !existing_dir(Pathname.pwd))
  end

  def git_fetch(remote: nil, branch: nil)
    error("Invalid remote `#{remote}`.") \
      if remote && !git_remotes.include?(remote)
    error("Invalid branch `#{branch}`.") \
      if branch && !git_branches.include?(branch)

    tell("Fetching from remote.", :blue)

    cmd  = "git fetch"
    cmd << " #{Shellwords.escape(remote)}" unless remote.nil?
    cmd << " #{Shellwords.escape(branch)}" unless branch.nil?

    exec_cmd(cmd, as_su: !existing_dir(Pathname.pwd))
  end

  def git_add(files: nil)
    error("Invalid files `#{files}`.") unless files.nil? || files.is_a?(Array)

    cmd  = "git add"
    if files.nil?
      cmd << " -A"
    else
      cmd << files.map { |f| Shellwords.escape(f) }.join(" ")
    end

    exec_cmd(cmd, as_su: !existing_dir(Pathname.pwd))
  end

  def git_commit(message: nil)
    tell("Performing commit.", :blue)

    cmd = "git commit -a"
    if message.nil?
      cmd << " --allow-empty-message"
    else
      cmd << " -m #{Shellwords.escape(message)}"
    end

    exec_cmd(cmd, as_su: !existing_dir(Pathname.pwd))
  end

  def git_normalize_url(url, default_protocol: "ssh")
    protocols = %w(https ssh)
    regexp = %r{
      ^
      (?<protocol>#{protocols.map{|p| "#{p}:"}.join("|")})?
      (?<username>[a-z0-9\-_]+)
      \/
      (?<repository>[a-z0-9\-_]+)
      $
    }xi
    md = url.match(regexp)
    return url unless md
    case md[:protocol] || default_protocol
    when "ssh"   then "git@github.com:#{md[:username]}/#{md[:repository]}"
    when "https" then "https://github.com/#{md[:username]}/#{md[:repository]}"
    else error("Invalid protocol for `#{url}`: " +
               "not in `[#{protocols.join(", ")}]`.")
    end
  end

end

# ☞ Utils → Vars ───────────────────────────────────────────────────────────────

module Fizzy::Vars

  include Fizzy::IO
  include Fizzy::Filesystem

  attr_reader :vars

  # Return a list of the available variables files.
  #
  def avail_vars(vars_dir_path)
    Pathname.glob(vars_dir_path.join("*"))
  end

  # Setup the variables that will be used during ERB processing.
  #
  # Those variables will be set into an instance field called `@vars`.
  #
  # After calling this method, you can directly access the variables using
  # `@vars` or using the attribute reader `vars`.
  #
  def setup_vars(vars_dir_path, name)
    info("vars: ", name)
    @vars = _setup_vars(vars_dir_path, name)
  end

  # Check if the feature with the provided name (`feature_name`) is enabled.
  #
  # Since the features are defined just using variables, before calling this
  # method be sure that `setup_vars` has already been called.
  #
  def has_feature?(feature_name)
    get_var!("features", single_match: :force).include?(feature_name.to_s)
  end

  # Filter the values associated to the features, keeping only those
  # associated to available features.
  #
  def data_for_features(info, sep: nil)
    data = []

    info.each do |feature_name, associated_value|
      if has_feature?(feature_name.to_sym)
        if associated_value.respond_to?(:call)
          data << associated_value.call
        else
          data << associated_value
        end
      end
    end

    if data.length == 1
      def data.inspect
        first
      end
    elsif sep
      def data.inspect
        join(sep)
      end
    end

    data
  end

  # Same of `get_var`, but raise an error if the variable hasn't been found or
  # is `nil`.
  #
  def get_var!(var_name, **opts)
    value = get_var(var_name, **opts)
    value.nil? ? error("Undefined variable: `#{var_name}`.") : value
  end

  # Return the variables matching the provided `name`.
  #
  # The variables object being looked up is the one returned from the
  # method `vars`.
  #
  # The result is normally a list of the matching variables; but if `expand`
  # is `true`, empty list is expanded to `nil` and a list of one element is
  # expanded to that element.
  #
  def get_var(var_name, type: nil, strict: false, single_match: false, expand: true)
    var = _get_var(vars, var_name, single_match: single_match)
    var = _typize_var(var_name, var, type, strict)

    if expand
      case var.length
      when 0 then nil
      when 1 then var.first
      else var
      end
    else
      var
    end
  end

  # Accept a list of variables (`vars` argument) and ensure they are correctly
  # typed, according to `type`.
  #
  # If `strict` is `true`, then no type convertion/normalization is done;
  # otherwise, try to guess the correct type.
  #
  def _typize_var(name, var, type, strict)
    Array(var).map do |var|
      if type.nil? || (type.to_s.end_with?("?") && var.nil?)
        var
      else
        case type.to_s.gsub(/\?$/, "").to_sym
        when :string, :str
          strict ? _ensure_type!(name, var, String) : var.to_s
        when :symbol, :sym
          strict ? _ensure_type!(name, var, Symbol) : var.to_s.to_sym
        when :integer, :int
          strict ? _ensure_type!(name, var, Integer) : Integer(var)
        when :boolean, :bool
          if strict
            _ensure_type!(name, var, TrueClass, FalseClass)
          else
            if var.nil?
              nil
            elsif var.is_a?(TrueClass) || var.to_s == "true"
              true
            elsif var.is_a?(FalseClass) || var.to_s == "false"
              false
            else
              error("Invalid value `#{var}` for variable `#{name}`: " +
                    "it can't be converted to a boolean.")
            end
          end
        when :path, :pth then
          if strict && !File.exist?(var)
            error("Invalid variable `#{name}`: `#{var}` doesn't exist")
          else
            Pathname.new(var)
          end
        when :file, :pth then
          if strict && !File.file?(var)
            error("Invalid variable `#{name}`: `#{var}` isn't a file")
          else
            Pathname.new(var)
          end
        when :directory, :dir then
          if strict && !File.directory?(var)
            error("Invalid variable `#{name}`: `#{var}` isn't a directory")
          else
            Pathname.new(var)
          end
        else
          error("Unhandled type `#{type}`. If you need support for a new type, " +
                "open an issue at `#{Fizzy::CFG.issues_url}`.")
        end
      end
    end
  end

  def _ensure_type!(name, var, *types)
    if types.any?{|type| var.is_a?(type)}
      var
    else
      error("Invalid type for variable `#{name}`: " +
            "it's not a `#{type.name}`.")
    end
  end

  # Returns a list of variables matching the provided `name`, chosen from `vars`.
  #
  # The argument `single_match` can be one of `[:force, true, false]`, to
  # respectively force, restrict to, don't return a single match (the first).
  #
  # This method effectively implements the logic to retrieve variables.
  #
  def _get_var(vars, name, single_match: :force)
    dot_split_regexp = /([^.]+)(?:\.|$)/

    name.to_s.scan(dot_split_regexp).map{|match_group| match_group[0]}
                 .reject(&:empty?)
                 .inject(vars) do |cur_obj, name_component|

      # Intermediate `cur_obj` are lists because every step returns a list.
      # If a step is not-final (i.e. intermediate), we need to be sure there
      # is only one element.
      if cur_obj.is_a?(Array)
        if cur_obj.length == 1
          cur_obj = cur_obj.first
        else
          error("Variabile name diverges: multiple intermediate paths are " +
                "taken (`[#{cur_obj}]`).")
        end
      end

      # Fill `nxt_obj`.
      nxt_obj = if cur_obj.has_key?(name_component) # Check for exact match.
                  Array[cur_obj[name_component]]
                else
                  # Check if there are elements with key matching
                  # `name_component` as regexp.
                  # Returns `nil` if nothing is found.
                  cur_obj.select do |k, v|
                    k =~ Regexp.new(/^#{name_component}$/)
                  end.values
                end

      # Adjust `nxt_obj`, according to `single_match` argument.
      nxt_obj = if single_match
                  if single_match == :force && nxt_obj.length != 1
                    error("Expected a single match for variable `#{name}`, " +
                          "but instead got `#{nxt_obj.length}`")
                  end
                  nxt_obj.first
                else
                  nxt_obj
                end

      break nil if nxt_obj.nil? || (nxt_obj.is_a?(Array) && nxt_obj.empty?)
      nxt_obj
    end
  end

  def _read_vars(vars_dir_path, name)
    yaml_file_path = find_yaml_path(vars_dir_path.join(name)) unless vars_dir_path.nil? || name.nil?

    if yaml_file_path
      [:yaml, File.read(yaml_file_path)]
    elsif !name.nil? && ENV.has_key?(name)
      [:json, ENV[name]]
    else
      [nil, nil]
    end
  end

  def _parse_parents_vars(fmt, content)
    dummy_regex = /none|nothing/i
    parents_regex = case fmt
    when :yaml then /^#\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*#\s*/
    when :json then /^\/\*\s*=>\s*inherits\s*(:\s+)?(?<parents>.+)\s*<=\s*\*\/\s*/
    else error("Unrecognized format: `#{fmt}`")
    end
    if md = content.match(parents_regex)
      md[:parents].split(",").map(&:strip).reject { |p| p =~ dummy_regex }
    else
      []
    end
  end

  def _parse_vars(fmt, content)
    case fmt
    when :yaml then YAML.load(content) || {}
    when :json
      begin
        JSON.parse(content)
      rescue
        error("Invalid JSON: `#{content}`.")
      end
    else error("Unrecognized format: `#{fmt}`")
    end
  end

  def _merge_with_parents_vars(self_vars, parents_vars)
    parents_vars.deep_merge(self_vars)
  end

  def _get_var_collisions(parents_vars)
    collisions = []
    parents_vars.each do |parent_vars|
      parent_vars_keys = parent_vars.fqkeys
      others_vars = parents_vars - [parent_vars]
      others_vars.each do |other_vars|
        other_vars_keys = other_vars.fqkeys
        common_keys = other_vars_keys & parent_vars_keys
        common_keys.each do |key|
          value_a = _get_var(parent_vars, key).first
          value_b = _get_var(other_vars, key).first
          if value_a != value_b
            collisions << { key: key, value_a: value_a, value_b: value_b }
          end
        end
      end
    end
    collisions.uniq do |c| # Remove duplicate collisions.
      [c[:key]] + [c[:value_a], c[:value_b]].sort
    end
  end

  def _merge_parents_vars(vars_dir_path, parents)
    parents.inject([]) do |acc, parent| # Vars for each parent.
      parent_vars = _setup_vars(vars_dir_path, parent)
      acc << parent_vars
      collisions = _get_var_collisions(acc)
      unless collisions.empty?
        error("Inconsistent variables specification:\n" + collisions.map { |c|
                "\t→ Collision with key=`#{c[:key]}`: " +
                "value_a=`#{c[:value_a]}` value_b=`#{c[:value_b]}`"
              }.join("\n"))
      end
      acc
    end.inject({}) do |acc, parent_vars| # Merge them.
      acc.deep_merge(parent_vars)
    end
  end

  def _setup_vars(vars_dir_path, name)
    fmt, content = _read_vars(vars_dir_path, name)
    error("Invalid vars: `#{name}`.") if fmt == nil || content == nil
    self_vars = _parse_vars(fmt, content)
    parents = _parse_parents_vars(fmt, content)
    parents_vars = _merge_parents_vars(vars_dir_path, parents)
    _merge_with_parents_vars(self_vars, parents_vars)
  end

end

# ☞ Utils → Locals ─────────────────────────────────────────────────────────────

module Fizzy::Locals

  include Fizzy::IO

  # Entry point for using the DSL defined by `Proxy` class.
  # The DSL is directly accessible inside the provided block.
  #
  def define_locals(&block)
    error("No requirements specification provided.") unless block_given?
    @locals_proxy = Fizzy::Locals::Proxy.new(self)
    @locals_proxy.instance_eval(&block)
  end

  # ┌──────────────────────────────────────────────────────────────────────────┐
  # ├→ Forward DSL calls to the `Proxy` ───────────────────────────────────────┤

  def local(name)
    @locals_proxy.local(name)
  end

  def local!(name)
    @locals_proxy.local!(name)
  end

  def local?(*names, &block)
    @locals_proxy.local?(*names, &block)
  end

  # └──────────────────────────────────────────────────────────────────────────┘

  # DSL used for defining locals.
  #
  class Proxy

    include Fizzy::IO

    attr_reader :locals

    def initialize(receiver)
      @receiver = receiver
      @locals   = {}
    end

    # ┌────────────────────────────────────────────────────────────────────────┐
    # ├→ DSL definition ───────────────────────────────────────────────────────┤

    # Create a new `local` fetching the value from the corresponding `variable`.
    #
    def variable(name, *args, **opts)
      name = name.to_s.to_sym

      local = @receiver.get_var(name, **opts.slice(:type, :strict))

      @locals[opts.fetch(:as, name).to_sym] = if local.nil?
                                                opts.fetch(:default, nil)
                                              else
                                                local
                                              end
    end

    # Create a new computed `local`, based upon other locals.
    #
    def computed(name, &block)
      name = name.to_s.to_sym
      error("Invalid local name `#{name}`: it's blank.") if name.empty?
      error("Cannot compute local `#{name}`.") unless block_given?

      @locals[name.to_sym] = @receiver.instance_exec(&block)
    end

    # Access the value of a local.
    #
    def local(name)
      @locals[name.to_sym]
    end

    # Access the value of a local or raise an error if it's not defined.
    #
    def local!(name)
      value = local(name)
      error("Undefined local `#{name}`.") if value.nil?
      value
    end

    # If all locals identified by `names` are available, evaluate the block
    # passing the locals' values.
    #
    def local?(*names, &block)
      values = names.collect{|name| local(name)}
      yield(*values) if values.compact.length == names.length
    end

    # └────────────────────────────────────────────────────────────────────────┘
  end

end

# ☞ Utils → Meta Commands ──────────────────────────────────────────────────────

# Manage commands declared in the meta file.
#
module Fizzy::MetaCommands

  include Fizzy::Git

  # Return a data structure containing the commands that can be specified in
  # the meta file.
  #
  # The data structure defines:
  # - The available command types (`available_commands.keys`).
  # - (Optionally) A validator that can be used to validate type-specific
  #   validation rules.
  # - The command executor: A `Lambda` containing the code used for executing
  #   that command.
  #
  def available_commands
    { "git_sync" => {
        "validator" => lambda { |spec|
          spec["dst"] = File.expand_path(spec["dst"]) if spec.has_key?("dst")
          status   = spec.has_key?("repo")
          status &&= spec.has_key?("dst")
        },
        "executor" => lambda { |spec|
          if File.directory? spec["dst"]
            FileUtils.cd(spec["dst"]) { git_pull }
          else
            git_clone(spec["repo"], spec["dst"])
          end
        }
      }
    }
  end

end

# ☞ Utils → Meta Info ──────────────────────────────────────────────────────────

# Access informations declared in the meta file.
#
module Fizzy::MetaInfo

  include Fizzy::IO
  include Fizzy::Vars

  # Return the normalized and validated meta object.
  #
  # Be sure to call `setup_vars` before calling this method.
  #
  def get_meta(meta_path, vars_path, elems_base_path, verbose)
    tell("Getting meta informations.", :blue)

    meta = YAML.load(File.read(meta_path))
    meta["all_elems_count"] = meta["elems"].count

    # ┌────────────────────────────────────────────────────────────────────────┐
    # ├→ Step 1: Normalize elements ───────────────────────────────────────────┤

    elem_erb_excluded_fields = ["only"]

    meta["elems"] = [] unless meta.has_key?("elems")

    meta["elems"] = meta["elems"].each_with_index.collect do |elem, idx|
      elem_identifier = elem["name"] || "src = #{elem["src"]}"
      info("\nElement: ", elem_identifier) if verbose

      # Step 1.1: Validate `only` and determine if the element is selected.
      if elem.has_key?("only") && !elem["only"].is_a?(Hash)
        error("The configuration element `#{elem_identifier}` has invalid " +
              "`only`: it's not a `Hash`.")
      end
      selected = selected_by_only?(elem["only"], verbose)

      # Step 1.2: Pre-process strings with ERB.
      if selected
        elem.each do |k, v|
          unless elem_erb_excluded_fields.include?(k)
            elem[k] = ERB.new(v).result(binding)
          end
        end
      end

      # Step 1.3: Validate and normalize `name`, `src`, `dst`, `fs_maps`.
      if selected
        error("Element `#{elem_identifier}` doesn't contain `src`.") \
          unless elem.has_key?("src")
        elem["name"] = elem["src"] unless elem.has_key?("name")
        error("Element `#{elem_identifier}` doesn't contain `dst`.") \
          unless elem.has_key?("dst")
        elem["fs_maps"] = []
      end

      selected ? elem : nil
    end.compact

    # Step 1.4: For each active elem, match the `src` field against the
    #           filesystem and determine filesystem mapping (`fs_maps`).
    meta["elems"].each do |elem|
      found = false

      Find.find(elems_base_path).
        select { |ebp| File.file?(ebp) }.
        each do |subfile_path|

        subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
                           Pathname.new(elems_base_path)).to_s
        if md = Regexp.new(elem["src"]).match(subfile_rel_path.gsub(/\.tt$/, ''))
          found = true
          dst_path = elem["dst"].gsub(/<([0-9]+)>/) do
            idx = Integer($1)
            unless (1..md.length) === idx
              error("Invalid `dst` for element `#{elem["name"]}`: nothing " +
                    "captured at index `#{idx}`.")
            else
              md[idx]
            end
          end
          elem["fs_maps"] << {
            "src_path" => Pathname.new(subfile_path).expand_path,
            "dst_path" => Pathname.new(dst_path).expand_path
          }
        end
      end

      warning("Inconsistency found for elem `#{elem["name"]}`: no file " +
              "matches src: `#{elem["src"]}`.") unless found
    end

    # ├────────────────────────────────────────────────────────────────────────┤
    # ├→ Step 2: Normalize commands ───────────────────────────────────────────┤

    command_excluded_erb_fields = ["only"]

    meta["commands"] = [] unless meta.has_key?("commands")

    meta["commands"] = meta["commands"].each_with_index.collect do |spec, idx|
      spec["name"] ||= "type = #{spec["type"]}, index = #{idx}"
      info("\nCommand: ", spec["name"]) if verbose

      # Step 2.1: Validate `only` and determine if the command is selected.
      error("The command `#{spec["name"]}` has invalid `only`: it's not " +
            "a `Hash`.") if spec.has_key?("only") && !spec["only"].is_a?(Hash)

      selected = selected_by_only?(spec["only"], verbose)

      if selected

        # Step 2.2: Pre-process strings with ERB.
        spec.each do |key, value|
          unless command_excluded_erb_fields.include?(key)
            spec[key] = ERB.new(value).result(binding)
          end
        end

        # Step 2.3: Validate `type`, `validator`, `executor`.
        if !spec.has_key?("type") ||
           !available_commands.keys.include?(spec["type"])
          error("The command `#{spec["name"]}` has invalid `type`: it's " +
                "not in `#{available_commands.keys}`.")
        end
        command = available_commands[spec["type"]]
        if command.has_key?("validator") && !command["validator"].is_a?(Proc)
          error("Invalid validator for command `#{spec["name"]}`: if " +
                "provided it should be a `Proc`.")
        end
        if !command.has_key?("executor") || !command["executor"].is_a?(Proc)
          error("Invalid executor for command `#{spec["name"]}`: it should " +
                "be a `Proc`.")
        end

        # Step 2.4: Use type-specific validator if it's defined.
        if command.has_key?("validator") && (
             !command["validator"].is_a?(Proc) ||
             !command["validator"].call(spec)
           )
          error("The validator for command `#{spec["name"]}` didn't pass.")
        end
      end

      selected ? spec : nil
    end.compact

    # └────────────────────────────────────────────────────────────────────────┘

    # Build the list of excluded files (needed by thor's `directory()`).
    all_files = Set.new(Find.find(elems_base_path)
                            .map{|f| Pathname.new(f).expand_path}
                            .select{|f| f.file?})
    src_paths = Set.new(
      meta["elems"].collect_concat do |elem|
        elem["fs_maps"].map{|m| m["src_path"]}
      end)
    vars_files = Pathname.glob(vars_path.join("*"), File::FNM_DOTMATCH)
    meta["system_files"]    = Set.new(vars_files << meta_path)
    meta["excluded_files"]  = all_files - src_paths - meta["system_files"]
    meta["all_files_count"] = all_files.count

    meta
  end

  # Return whether the provided `only` specification is evaluated as an allows
  # and not as a denies.
  #
  def selected_by_only?(only, verbose)
    unless only
      selected = true
      info(" ↳ ", "#{colorize("✔", :green)} (`only` is empty).") if verbose
    else
      wants_features = only.has_key?("features")
      wants_vars     = only.has_key?("vars")

      feat_ok = if wants_features
                  only["features"].any? do |feature|
                    case feature
                    when Array
                      feature.all? { |f| has_feature?(f) }
                    else
                      has_feature?(feature)
                    end
                  end
                else
                  true
                end
      vars_ok = wants_vars ?
          only["vars"].any? { |var| !get_var(var, single_match: force).nil? } :
          true

      selected   = !wants_features && !wants_vars
      selected ||= feat_ok && vars_ok

      info(" ↳ ", "#{colorize("✔", :green)} (`only` is present and " +
                  "satisfied).") if selected && verbose
    end

    info(" ↳ ", "#{colorize("✘", :red)} (`only` is present and didn't " +
                "match).") if !selected && verbose

    selected
  end

end

# ☞ Utils → Meta Elements ──────────────────────────────────────────────────────

# Manage elements declared in the meta file.
#
module Fizzy::MetaElements

  include Fizzy::IO
  include Fizzy::Execution

  # Return a list of functions capable to apply modifications on the system
  # based on the current elements configuration instance.
  #
  # In particular, an applier work for each element installed.
  #
  def elements_appliers
    [ lambda { |elem| # Create parent directories.
        elem["fs_maps"].each do |m|
          parent_dir = m["dst_path"].dirname
          if elem.has_key?("perms")
            l_ex_dir_path = f_noex_dir_path = parent_dir
            while !l_ex_dir_path.directory?
              f_noex_dir_path = l_ex_dir_path
              l_ex_dir_path   = l_ex_dir_path.dirname
            end
          else
            l_ex_dir_path = f_noex_dir_path = nil
          end
          # From here, we have the following variable set:
          # - `l_ex_dir_path`: Longest path prefix which points to an existing
          #                    directory.
          # - `f_noex_dir_path`: Path of the first directory after the prefix
          #                      which points to an existing dir.
          if !parent_dir.directory?
            exec_cmd("mkdir -p #{Shellwords.escape(parent_dir)}",
                     as_su: !existing_dir(parent_dir))
          end
        end
      },
      lambda { |elem| # Create a symlink for each elements' `src_path`.
        elem["fs_maps"].each do |m|
          tell("  #{m["src_path"]} ← #{m["dst_path"]}") if @verbose
          cmd = "ln -s"
          should_link = if m["dst_path"].file?
            if m["dst_path"].realpath != m["src_path"]
              cmd << " -f"
              quiz("The destination file `#{m["dst_path"]}` already " +
                   "exists. Overwrite")
            else
              false
            end
          elsif m["dst_path"].directory?
            if quiz("The destination file `#{m["dst_path"]}` is a " +
                    "directory. Delete it")
              exec_cmd("rm -Rf #{m["dst_path"]}",
                       as_su: !existing_dir(m["dst_path"].dirname))
            end
          else
            # Link does not exist yet.
            true
          end

          if should_link
            cmd << " #{Shellwords.escape m["src_path"]}"
            cmd << " #{Shellwords.escape m["dst_path"]}"
            exec_cmd(cmd, as_su: !existing_dir(m["dst_path"].dirname))
          end
        end
      },
      lambda { |elem| # Change perms of the instantiated files (if specified).
        if elem.has_key?("perms")
          elem["fs_maps"].each do |m|
            tell("Changing permissions of #{m["src_path"]} to " +
                 elem["perms"]) if @verbose
            exec_cmd("chmod -R #{Shellwords.escape(elem["perms"])} " +
                     Shellwords.escape(m["src_path"]),
                     as_su: !File.owned?(m["src_path"]))
          end
        end
      }
    ]
  end

end

# ☞ Commands → Base ────────────────────────────────────────────────────────────

# Base class for all fizzy commands.
#
class Fizzy::BaseCommand < Thor

  include Thor::Actions

  include Fizzy::Environment
  include Fizzy::Execution
  include Fizzy::Filesystem
  include Fizzy::Git
  include Fizzy::IO
  include Fizzy::Vars
  include Fizzy::Locals
  include Fizzy::MetaInfo
  include Fizzy::MetaElements
  include Fizzy::MetaCommands

  # Common options, shared among many commands.
  #
  SHARED_OPTIONS = {
    verbose: {
      default: false,
      type:    :boolean,
      aliases: :v,
      desc:    "Whether the output should be verbose."
    },
    run_mode: {
      default: "normal",
      aliases: :R,
      enum:    %w(normal paranoid dry),
      desc:    "Ask confirmation for each filesystem operation."
    },
    fizzy_dir: {
      default: Fizzy::CFG.default_fizzy_dir,
      aliases: :F,
      desc:    "The root path for the directory internally used by fizzy."
    },
    cfg_url: {
      default: nil,
      aliases: :U,
      desc: "The URL to the repository holding config."
    },
    cfg_name: {
      default: nil,
      aliases: :C,
      desc:    "The name of the configuration that should be used."
    },
    inst_name: {
      default: nil,
      aliases: :I,
      desc:    "The name for the configuration instance to be used."
    },
    vars_name: {
      default: nil,
      aliases: :V,
      desc:    "The name for the variables file to be used."
    },
    meta_name: {
      default: Fizzy::CFG.default_meta_name,
      aliases: :M,
      desc:    "The name of the meta file."
    }
  }

  class << self

    include Fizzy::IO

    # Get a shared option.
    #
    def shared_option(name, required: false)
      args = SHARED_OPTIONS[name].dup
      error("Invalid option `#{name}`: it doesn't exist.") if args.nil?

      if required
        args.delete(:default)
        args[:required] = true
      elsif !args.has_key?(:default)
        error("Invalid shared option `#{name}`: doesn't have a default value.")
      end

      [name, args]
    end

  end

end

# ☞ Commands → Cfg ─────────────────────────────────────────────────────────────

class Fizzy::CfgCommand < Fizzy::BaseCommand

  def self.source_root
    "/"
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  desc("details", "Show configuration details.")
  def details
    # Prepare paths before considering details.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta: false,
                            valid_cfg:  :readonly,
                            valid_inst: false,
                            cur_cfg_name: options.cfg_name)
    # Print details.
    tell("Available variable files:", :cyan)
    avail_vars(paths.cur_cfg_vars).each do |path|
      name = path.basename(path.extname)
      tell("\t#{colorize(name, :magenta)}")
    end
  end

  method_option(*shared_option(:fizzy_dir))
  desc("cleanup", "Cleanup the fizzy storage.")
  def cleanup
    # Prepare paths for cleanup.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta: false,
                            valid_cfg:  false,
                            valid_inst: false)

    # Perform cleanup.
    status = exec_cmd("rm -Rf #{Shellwords.escape(paths.root)}") \
      if quiz("Do you want to remove the fizzy root directory `#{paths.root}`")

    # Inform user about the cleanup status.
    if status
      tell("Successfully cleaned: `#{paths.root}`.", :green)
    elsif status.nil?
      warning("Cleanup skipped.", ask_continue: false)
    else
      error("Failed to cleanup: `#{paths.root}`.", :red)
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc("cd",
       "Change directory to the configuration directory " +
       "(useful for extensive filesystem manipulations).")
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            valid_cfg:    !options.cfg_name.nil?,
                            cur_cfg_name: options.cfg_name)

    # Changing directory.
    dir_path = paths.cur_cfg || paths.cfg
    tell("Changing directory to: `#{dir_path}`.", :cyan)
    FileUtils.cd(dir_path)
    system(get_env!(:SHELL))

    # Inform user about the changing directory status.
    tell("CD done in: `#{dir_path}`.", :green)
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name))
  desc("edit PATTERN", "Find the files relative to PATTERN and edit them.")
  def edit(pattern)
    # Prepare stuff for editing.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name)
    find_path = (paths.cur_cfg || paths.cfg).join(pattern)
    cfg_files = if find_path.exist?
                  Array[find_path]
                else
                  Pathname.glob("#{find_path}*", File::FNM_DOTMATCH).to_a.
                    select(&:file?).
                    reject{|path| path.to_s =~ /\.git/}
                end

    cfg_files_arg = cfg_files.collect{|path| Shellwords.escape(path)}
                             .join(" ")
                             .strip

    # Perform edit.
    if cfg_files_arg.empty?
      warning("No files matching `#{cfg_name}` have been found.",
              ask_continue: false)
      status = nil
    else
      tell("Editing configuration file(s): `#{cfg_files_arg}`.", :cyan)
      status = system("#{Fizzy::CFG.editor} #{cfg_files_arg}")
    end

    # Inform user about the editing status.
    if status
      tell("Successfully edited: `#{cfg_files_arg}`.", :green)
    elsif status.nil?
      warning("Editing skipped.", ask_continue: false)
    else
      error("Failed to edit: `#{cfg_files_arg}`.", :red)
    end
  end

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name, required: true))
  method_option(*shared_option(:cfg_url))
  desc("sync", "Synchronize the remote repository with the local one.")
  def sync
    # Prepare stuff for syncing.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:   false,
                            valid_cfg:    false,
                            valid_inst:   false,
                            cur_cfg_name: options.cfg_name)

    # Perform sync.
    sync_result = if paths.cur_cfg.directory?
      tell("Syncing from origin", :blue)
      status = nil
      FileUtils.cd(paths.cur_cfg) do
        # Perform fetch, because we need to know if there are remote changes,
        # so we need to know the updated remote commit hash.
        tell("Fetching informations from origin.", :cyan)
        status = git_fetch
        # (Optional) Perform commit.
        if status && git_has_local_changes(paths.cur_cfg)
          tell "The configuration has the following local changes:\n" +
              "#{colorize(git_local_changes(paths.cur_cfg), :white)}", :cyan
          should_commit = quiz("Do you want to commit them all")
          if should_commit
            commit_msg = quiz("Type the commit message", type: :string)
            status   = git_add
            status &&= git_commit(message: commit_msg)
          else
            status = false
          end
        end
        # (Optional) Perform pull.
        status = git_pull if status && git_should_pull(paths.cur_cfg)
        # (Optional) Perform push.
        status = git_push if status && git_should_push(paths.cur_cfg)
      end
      status
    else
      git_clone(options.cfg_url, paths.cur_cfg)
    end

    # Inform user about sync status.
    if sync_result
      tell("Synced to: `#{paths.cur_cfg}`.", :green)
    else
      error("Unable to sync.")
    end
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("instantiate", "Create a configuration instance in the current machine.")
  def instantiate
    # Before instantiation.
    paths = prepare_storage(options.fizzy_dir,
                            meta_name:     options.meta_name,
                            valid_cfg:     :readonly,
                            valid_inst:    false,
                            cur_cfg_name:  options.cfg_name,
                            cur_inst_name: options.inst_name)
    setup_vars(paths.cur_cfg_vars, options.vars_name)

    meta = get_meta(paths.cur_cfg_meta, paths.cur_cfg_vars, paths.cur_cfg,
                    options.verbose)

    info("meta: ", "#{colorize(meta["elems"].count, :green)}/" +
                   "#{meta["all_elems_count"]} elem(s) selected.")
    info("meta: ", "#{colorize(meta["excluded_files"].count, :red)}/" +
                   "#{meta["all_files.count"]} file(s) excluded.")
    tell

    # Create a configuration instance.
    tell("Creating a configuration instance named `#{options.inst_name}` " +
         "from: `#{paths.cur_cfg}`.", :blue)

    exclude_pattern = /\.git|README/
    meta["excluded_files"].each do |excluded_file|
      exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
    end

    begin
      directory(paths.cur_cfg, paths.cur_inst, exclude_pattern: exclude_pattern)
    rescue SyntaxError
      error("Error while processing the template: `#{$fizzy_cur_template}`.")
    end

    # After instantiation.
    tell("Created the configuration instance in: `#{paths.cur_inst}`.", :green)
  end

end

# ☞ Commands → Inst ────────────────────────────────────────────────────────────

class Fizzy::InstCommand < Fizzy::BaseCommand

  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name))
  desc("cd", "Change directory to the instance directory " +
             "(useful for extensive filesystem manipulations).")
  def cd
    # Prepare stuff for changing directory.
    paths = prepare_storage(options.fizzy_dir,
                            valid_meta:    false,
                            valid_cfg:     false,
                            valid_inst:    !options.inst_name.nil?,
                            cur_inst_name: options.inst_name)

    # Changing directory.
    dir_path = paths.cur_inst || paths.inst
    tell("Changing directory to: `#{dir_path}`.", :cyan)
    FileUtils.cd(dir_path)
    system get_env!(:SHELL)

    # Inform user about the changing directory status.
    tell("CD done in: `#{dir_path}`.", :green)
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("install", "Install the current configuration instance in the system.")
  def install
    # Prepare stuff for performing install.
    @run_mode = options.run_mode.to_sym
    @verbose  = options.verbose
    paths = prepare_storage(options.fizzy_dir,
                            valid_cfg:     false,
                            meta_name:     options.meta_name,
                            cur_inst_name: options.inst_name)
    setup_vars(paths.cur_inst_vars, options.vars_name)

    meta = get_meta(paths.cur_inst_meta, paths.cur_inst_vars, paths.cur_inst,
                    options.verbose)

    # Install the instance into the system.
    tell("Installing the configuration instance `#{options.inst_name}` " +
         "into the system.", :blue)

    meta["elems"].each do |elem|
      tell("Installing element: `#{elem["name"]}`.", :cyan)
      elements_appliers.each { |applier| applier.call(elem) }
      if elem["notes"]
        tell("Notes for `#{elem["name"]}`:", :yellow)
        tell(elem["notes"].split("\n").collect { |s| "  #{s}" }.join("\n"))
      end
    end
    meta["commands"].each do |spec|
      tell("Executing command: `#{spec["name"]}`.", :cyan)
      available_commands[spec["type"]]["executor"].call(spec)
    end

    # Inform the user about installation status.
    tell("The configuration instance `#{options.inst_name}` has been " +
         "installed into the system", :green)
  end

end

# ☞ Commands → Main ────────────────────────────────────────────────────────────

class Fizzy::MainCommand < Fizzy::BaseCommand

  desc("cfg SUBCOMMAND ...ARGS", "Manage the Fizzy configuration " +
                                 "(without modifying the host system).")
  subcommand("cfg", Fizzy::CfgCommand)

  desc("inst SUBCOMMAND ...ARGS", "Manage a configuration instance")
  subcommand("inst", Fizzy::InstCommand)

  desc("usage", "Show how to use Fizzy.")
  def usage
    url = URI.join(Fizzy::CFG.static_files_base_url, "README.md")
    res = Net::HTTP.get_response(url)
    if res.is_a?(Net::HTTPSuccess)
      tell("\n#{res.body}\n")
    else
      error("Network error: cannot retrieve `#{url}`.")
    end
  end

  method_option(*shared_option(:verbose))
  method_option(*shared_option(:run_mode))
  method_option(*shared_option(:fizzy_dir))
  method_option(*shared_option(:cfg_name,  required: true))
  method_option(*shared_option(:inst_name, required: true))
  method_option(*shared_option(:vars_name, required: true))
  method_option(*shared_option(:meta_name))
  desc("quick-install", "Quickly install a configuration.")
  def quick_install
    invoke(Fizzy::CfgCommand, "instantiate", [],
           cfg_name:  options.cfg_name,
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           verbose:   options.verbose)
    invoke(Fizzy::InstCommand, "install", [],
           vars_name: options.vars_name,
           inst_name: options.inst_name,
           fizzy_dir: options.fizzy_dir,
           meta_name: options.meta_name,
           run_mode:  options.run_mode,
           verbose:   options.verbose)
  end
  map :qi => :quick_install

end

# ☞ Main ───────────────────────────────────────────────────────────────────────

# Entry point.
Fizzy::MainCommand.start(ARGV) if $0 == __FILE__

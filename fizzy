#!/usr/bin/env ruby
# coding: utf-8
#
###############################################################################
#                                                                             #
# File informations:                                                          #
# - Name:    fizzy                                                            #
# - Summary: The script for invoking Fizzy commands                           #
# - Authors:                                                                  #
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             #
# - Contributors:                                                             #
#   - Luca Molari <molari.luca@gmail.com> (lmolr)                             #
#   Except:                                                                   #
#   - Hash#deep_merge:                                                        #
#     - From: http://www.ruby-forum.com/topic/142809                          #
#     - Author: Stefan Rusterholz                                             #
#                                                                             #
# Project informations:                                                       #
#   - Homepage:        https://github.com/alem0lars/fizzy                     #
#   - Getting started: see README.md in the project root folder               #
#                                                                             #
# License: Apache v2.0 (see below)                                            #
#                                                                             #
###############################################################################
#                                                                             #
# Licensed to the Apache Software Foundation (ASF) under one more contributor #
# license agreements.  See the NOTICE file distributed with this work for     #
# additional information regarding copyright ownership. The ASF licenses this #
# file to you under the Apache License, Version 2.0 (the "License"); you may  #
# not use this file except in compliance with the License.                    #
# You may obtain a copy of the License at                                     #
#                                                                             #
#   http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                             #
# Unless required by applicable law or agreed to in writing, software         #
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   #
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            #
# See the License for the specific language governing permissions and         #
# limitations under the License.                                              #
#                                                                             #
###############################################################################


# requires {{{

require 'fileutils'
require 'find'
require 'ostruct'
require 'net/http'
require 'pathname'
require 'yaml'

begin
  require 'thor'
rescue
  puts '[error] thor is not installed'
  exit(-1)
end

# }}}

# global constants {{{
  
RUBY_PLATFORM_IS_OSX   = RUBY_PLATFORM =~ /darwin$/
RUBY_PLATFORM_IS_LINUX = RUBY_PLATFORM =~ /-linux$/

# }}}

# configuration {{{

# Configure the default Fizzy root directory.
$DEF_FIZZY_DIR = ENV['FIZZY_DIR']
if RUBY_PLATFORM_IS_LINUX
  $DEF_FIZZY_DIR ||= '/var/tmp/fizzy'
elsif RUBY_PLATFORM_IS_OSX
  $DEF_FIZZY_DIR ||= '/Library/Application Support/Fizzy'
end

# }}}

# ruby classes extensions {{{

# Monkey-patch to retrieve the template currently processed.
class Thor
  module Actions
    old_template = instance_method(:template)
    define_method :template, ->(source, *args, &blk) do
      $fizzy_cur_template = source
      old_template.bind(self).(source, *args, &blk)
    end
  end
end

class Hash
  def deep_merge(second)
    merger = proc do |key, v1, v2|
      if Hash === v1 && Hash === v2
        v1.merge(v2, &merger)
      elsif Array === v1 && Array === v2
        (Set.new(v1) + Set.new(v2)).to_a
      else
        v2
      end
    end
    self.merge(second, &merger)
  end
end

# }}}


module Fizzy

  module Utils # {{{

    # git {{{

    def git_info(git_root_path)
      info = nil
      FileUtils.cd(git_root_path) do
        info = {
          :local  => `git rev-parse @`.strip,
          :remote => `git rev-parse @{u}`.strip,
          :base   => `git merge-base @ @{u}`.strip
        }
      end
      info
    end

    def git_local_changes(git_root_path)
      `git status -uall --porcelain`.strip
    end

    def git_has_local_changes(git_root_path)
      !git_local_changes(git_root_path).empty?
    end

    def git_should_pull(git_root_path)
      info = git_info(git_root_path)
      info[:remote] != info[:base]
    end

    def git_should_push(git_root_path)
      info = git_info(git_root_path)
      info[:local] != info[:base]
    end

    # }}}

    # meta {{{

    ## Make sure you call setup_vars before calling this method.
    def get_meta(meta_path, vars_path, tmp_path, elems_base_path, verbose)
      say 'Getting meta informations.', :blue
      erb_excluded_fields = ['only']

      meta = YAML.load(File.read(meta_path))
      meta["all_elems_count"] = meta['elems'].count

      meta['elems'] = meta['elems'].each_with_index.collect do |elem, idx|
        elem_identifier = elem['name'] || "src:'#{elem['src']}'"
        info("\nElement: ", elem_identifier) if verbose

        # 1: Validate 'only' and determine if the element is selected.
        if elem.has_key?('only') && !elem['only'].is_a?(Hash)
          error("The configuration element `#{elem_identifier}` has invalid `only`: it's not a `Hash`.")
        end
        unless elem.has_key?('only')
          selected = true
          info(' ↳ ', "#{set_color('✔', :green)} (`only` is empty).") if verbose
        else
          only = elem['only']
          wants_features = only.has_key?('features')
          wants_vars = only.has_key?('vars')
          feat_ok = wants_features ? only['features'].any? { |f| has_feature? f } : true
          vars_ok = wants_vars ? only['vars'].any? { |v| !get_var(v).nil? } : true

          selected = !wants_features && !wants_vars
          selected ||= (feat_ok && vars_ok)

          if selected && verbose
            info ' ↳ ', "#{set_color('✔', :green)} (`only` is present and satisfied)."
          end
        end

        info(' ↳ ', "#{set_color('✘', :red)} (`only` is present and didn't match).") if !selected && verbose

        # 2: Pre-process strings with ERB.
        if selected
          elem.each do |k, v|
            unless erb_excluded_fields.include? k
              elem[k] = ERB.new(v).result(binding)
            end
          end
        end

        # 3: Validate and normalize 'name', 'src', 'dst', 'fs_maps'.
        if selected
          unless elem.has_key?('src')
            error("Element `#{elem_identifier}` doesn't contain `src`.")
          end
          unless elem.has_key?('name')
            elem['name'] = elem['src']
          end
          unless elem.has_key?('dst')
            error("Element `#{elem_identifier}` doesn't contain `dst`.")
          end
          elem['fs_maps'] = []
        end

        next unless selected
        elem
      end.compact!

      FileUtils.cd(tmp_path) do # Stay in a safe place.

        # For each active elem, match the `src` field  against the filesystem
        # and determine filesystem mapping (`fs_maps`).
        meta['elems'].each do |elem|
          found = false

          Find.find(elems_base_path).each do |subfile_path|
            subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
              Pathname.new(elems_base_path)).to_s
            if md = Regexp.new(elem['src']).match(subfile_rel_path)
              found = true
              dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
                idx = Integer($1)
                unless (1..md.length) === idx
                  error("Invalid 'dst' for element `#{elem['name']}`: nothing " +
                        "captured at index `#{idx}`.")
                else
                  md[idx]
                end
              end
              elem['fs_maps'] << {
                'src_path' => subfile_path,
                'dst_path' => dst_path
              }
            end
          end

          unless found
            warning "Inconsistency found for elem `#{elem['name']}`: no file matches src: `#{elem['src']}`."
          end

        end

        # build the list of excluded files (needed by thor's `directory()`)
        all_files = Set.new(Find.find(elems_base_path).select { |f| File.file? f})
        src_paths = Set.new(
          meta['elems'].collect_concat do |elem|
            elem['fs_maps'].collect { |m| m['src_path'] }
          end
        )
        vars_files = Dir.glob(File.join(vars_path, '*'), File::FNM_DOTMATCH)
        meta['system_files'] = Set.new(vars_files << meta_path)
        meta['excluded_files'] = all_files - src_paths - meta['system_files']
        meta['all_files_count'] = all_files.count
      end

      meta
    end

    # }}}

    # vars {{{

    attr_reader :vars

    def setup_vars(vars_path, vars_file_name)
      say 'setting up vars', :blue
      vars = {}
      dummy_names_regex = /none|nothing/i
      inherits_regex = /#=>\s*inherits:\s*(?<inherits_name>[^\s]+)\s*<=#/i
      nesting = 0

      read_vars_file = lambda do |file_name|
        inherit_str = nesting == 0 ?
                        'vars tree: ' :
                        ' ' * (11 + (nesting - 1) * 2) + '↳ '
        info inherit_str, file_name
        file_path = File.join(vars_path, "#{file_name}.yml")
        file_content = File.read(file_path)

        # Find the name of the file to be inherited.
        inherits_name = file_content.match(inherits_regex)[:inherits_name]

        # Load the file that should be inherited (if any) by calling this
        # function recursively and merging the read variables into `vars`.
        if inherits_name && !(inherits_name =~ dummy_names_regex)
          inherits_file_path = File.join(vars_path, "#{inherits_name}.yml")
          unless File.file?(inherits_file_path)
            error("Inherited variables file doesn't exist: `#{inherits_name}`")
          end
          nesting += 1
          vars = vars.deep_merge(read_vars_file.call(inherits_name))
        end

        # Base case: read the yaml file (parsing possible erb template
        # icecreams) and store the read variables into `vars`.
        vars = vars.deep_merge(YAML.load(ERB.new(file_content).result) || {})
      end

      read_vars_file.call(vars_file_name)

      @vars = vars

      say ''
    end

    def get_var(var_name)
      dot_split_regexp = /([^.]+)(?:\.|$)/
      var_name.to_s
          .scan(dot_split_regexp).map { |match_group| match_group[0] }
          .reject(&:empty?)
          .inject(vars) do |cur_obj, name_component|

        nxt_obj = if cur_obj.has_key?(name_component)
          cur_obj[name_component]
        else
          nil
        end
        nxt_obj or break nil
      end
    end

    def get_var!(var_name)
      get_var(var_name) or raise "Undefined or `nil` variable: `#{var_name}`."
    end

    def has_feature?(feature_name)
      get_var!('features').include? feature_name.to_s
    end

    # }}}

    # env / host system {{{

    def get_env(envvar_name)
      ENV[envvar_name.to_s]
    end

    def get_env!(envvar_name)
      get_env(envvar_name) or
        raise "Undefined environment variable: `#{envvar_name}`"
    end

    def is_osx?;   RUBY_PLATFORM_IS_OSX   end
    def is_linux?; RUBY_PLATFORM_IS_LINUX end

    # }}}

    # commands {{{

    def exec_cmd(cmd, as_su: false)
      full_cmd = as_su ? "sudo #{cmd}" : cmd

      really_run = case @run_mode
                   when :normal
                     true
                   when :paranoid
                     quiz("Do you want to run the command `#{full_cmd}`")
                   when :dry
                     false
                   else
                     true
                   end

      if really_run || @run_mode == :dry
        if as_su
          say "[sudo] #{cmd}", :magenta
        else
          say cmd, :magenta
        end
      end

      if really_run
        status = system(full_cmd)
        warning "Command `#{full_cmd}` failed." unless status
        status
      end
    end

    # }}}

    # filesystem {{{

    def existing_dir(path, writable: true)
      dir_path = path
      while !File.directory?(dir_path)
        dir_path = File.dirname(dir_path)
      end
      (writable && !File.writable?(dir_path)) ? nil : dir_path
    end

    def prepare_storage(root_path, valid_cfg: true, valid_inst: true, cur_inst_name: nil)
      # paths based on internal conventions
      parent_path        = File.expand_path(File.dirname(root_path))
      tmp_path           = File.join(root_path, 'tmp')

      cfg_path           = File.join(root_path, 'cfg')
      cfg_vars_path      = File.join(cfg_path,  'vars')
      cfg_meta_path      = File.join(cfg_path,  'meta.yml')

      inst_path          = File.join(root_path, 'inst')
      cur_inst_path      = cur_inst_name && File.join(inst_path, cur_inst_name)
      cur_inst_vars_path = cur_inst_path && File.join(cur_inst_path, 'vars')
      cur_inst_meta_path = cur_inst_path && File.join(cur_inst_path, 'meta.yml')

      # validate storage correctness
      if ((File.directory?(root_path)  && !File.writable?(root_path)) ||
          File.file?(root_path)                                       ||
          (!File.directory?(root_path) && !File.writable?(parent_path)))
        error("No write permissions in Fizzy storage at path `#{root_path}`.")
      end
      if ((File.directory?(tmp_path) && !File.writable?(tmp_path)) ||
          File.file?(tmp_path))
        error('The temporary directory `#{tmp_path}` already exists but is not writable.')
      end
      if valid_cfg
        if !File.directory?(root_path)
          error("The Fizzy root directory `#{root_path}` doesn't exist (maybe you need to run: `fizzy cfg sync`).")
        end
        if !File.directory?(cfg_path) || !File.writable?(cfg_path)
          error('The configuration directory `#{cfg_path}` already exists but is not writable.')
        end
        if !File.file?(cfg_meta_path)
          error("The configuration directory `#{cfg_meta_path}` is invalid: not a valid meta file.")
        end
        if !File.directory?(cfg_vars_path)
          error("The variables directory `#{cfg_vars_path}` is invalid: doesn't exist.")
        end
      end
      if valid_inst
        if !File.directory?(root_path)
          error("The Fizzy root directory `#{root_path}` doesn't exist (maybe you need to run: `fizzy cfg sync`).")
        end
        if !File.directory?(cur_inst_path) || !File.writable?(cur_inst_path)
          error('The current instance `#{cur_inst_name}` is stored in an invalid path (`#{cur_inst_path}`): already exists but is not writable.')
        end
        if !File.file?(cur_inst_meta_path)
          error("The meta file path (`cur_inst_meta_path`) for the current instance `#{cur_inst_name}` is invalid: doesn't exist or isn't a regular file.")
        end
        if !File.directory?(cur_inst_vars_path)
          error("The variables directory (`#{cur_inst_vars_path}`) for the current instance `#{cur_inst_name}` is invalid: doesn't exist or isn't a directory")
        end
      end

      # create non-existing internal directories
      FileUtils.mkdir_p(root_path)     unless File.directory?(root_path)
      FileUtils.mkdir_p(tmp_path)      unless File.directory?(tmp_path)
      FileUtils.mkdir_p(inst_path)     unless File.directory?(inst_path)
      FileUtils.mkdir_p(cur_inst_path) if cur_inst_path && !File.directory?(cur_inst_path)

      # return the known storage paths
      OpenStruct.new(
        :root          => root_path,
        :tmp           => tmp_path,
        :cfg           => cfg_path,
        :cfg_vars      => cfg_vars_path,
        :cfg_meta      => cfg_meta_path,
        :inst          => inst_path,
        :cur_inst      => cur_inst_path,
        :cur_inst_vars => cur_inst_vars_path,
        :cur_inst_meta => cur_inst_meta_path)
    end

    # }}}

    # i/o & error handling {{{

    def quiz(question, type: :bool)
      answer = ask "#{question.strip}? ", :magenta
      case type
      when :bool
        if answer =~ /y|ye|yes|yeah|ofc/i
          true
        elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
          false
        else
          say 'Answer misunderstood', :yellow
          quiz(question, :type => type)
        end
      when :string
        if answer.empty?
          warning 'Empty answer', :ask_continue => false
          quiz(question, :type => type)
        else
          answer
        end
      else
        error "Unhandled question type: `#{type}`."
      end
    end

    def info(prefix, msg)
      say("#{set_color(prefix, :cyan)}#{set_color(msg, :white)}")
    end

    def warning(msg, ask_continue: true)
      say msg, :yellow
      exit(-1) if ask_continue && !quiz('continue')
    end

    def error(msg)
      say msg, :red
      exit(-1)
    end

    # }}}

  end # }}}


  # subcommands {{{

  class Cfg < Thor # {{{

    include Thor::Actions
    include Fizzy::Utils

    desc 'add', 'Import an existing configuration.'
    def add
      error('WIP, check later!')
    end

    desc 'add', 'Add a new configuration.'
    def add
      error('WIP, check later!')
    end

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    desc 'edit CFG_NAME', 'Find the files relative to CFG_NAME and edit them.'
    def edit(cfg_name)
      # Prepare stuff for editing.
      paths = prepare_storage(options.fizzy_dir, :valid_inst => false)
      find_path = File.join(paths.cfg, cfg_name)
      cfg_files_arg = (File.exist?(find_path) ?
          find_path :
          Dir.glob("#{find_path}*", File::FNM_DOTMATCH).to_a.delete_if { |elem|
            elem =~ /\.git/
          }.join(' ')
      ).strip
      editor = ENV['EDITOR'] || 'vim'

      # Perform edit
      if cfg_files_arg.empty?
        warning "No files matching `#{cfg_name}` have been found.", :ask_continue => false
        status = nil
      else
        say "Editing configuration file(s): `#{cfg_files_arg}`.", :cyan
        status = system("#{editor} #{cfg_files_arg}")
      end

      # Inform user about the editing status.
      if status
        say "Successfully edited: `#{cfg_files_arg}`.", :green
      elsif status.nil?
        warning 'Editing skipped.', :ask_continue => false
      else
        error "Failed to edit: `#{cfg_files_arg}`", :red
      end
    end

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :url, :default => nil,
           :desc => 'The url to the repository holding config (currently supported: `git`)'
    desc 'sync', 'Synchronize the remote repository with the local one.'
    def sync
      # Prepare stuff for syncing.
      paths = prepare_storage(options.fizzy_dir,
                              :valid_cfg => false, :valid_inst => false)

      # Perform sync.
      sync_result = if File.directory?(paths.cfg)
        say 'Syncing from origin', :blue
        status = nil
        FileUtils.cd(paths.cfg) do
          # Perform fetch, because we need to know if there are remote changes, so we need to know the updated remote commit hash.
          say 'Fetching informations from origin', :cyan
          status = system('git fetch origin')
          # (Optional) Perform commit.
          if status && git_has_local_changes(paths.cfg)
            say "The configuration has the following local changes:\n#{set_color(git_local_changes(paths.cfg), :white)}", :cyan
            should_commit = quiz 'Do you want to commit them all'
            if should_commit
              commit_msg = quiz 'Type the commit message', :type => :string
              say 'Performing commit.', :cyan
              status   = system('git add -A')
              status &&= system("git commit -am \"#{commit_msg}\"")
            else
              status = false
            end
          end
          # (Optional) Perform pull.
          if status && git_should_pull(paths.cfg)
            say 'Performing pull.', :cyan
            status   = system('git pull origin master')
            status &&= system('git submodule foreach git checkout master')
            status &&= system('git submodule foreach git merge origin/master')
          end
          # (Optional) Perform push.
          if status && git_should_push(paths.cfg)
            say 'Performing push.', :cyan
            status = system('git push origin master')
          end
        end
        status
      else
        say "Syncing from remote repo: `#{options.url}`.", :blue
        error('Invalid url option.') if options.url.nil?
        system("git clone --recursive #{options.url} #{paths.cfg}")
      end

      # Inform user about sync status.
      if sync_result
        say "Synced to: `#{paths.cfg}`.", :green
      else
        error 'Unable to sync.'
      end
    end

    option :vars_name, :required => true,
           :desc => 'The name for the variables file to be used.'
    option :inst_name, :required => true,
           :desc => 'The name for the new configuration instance.'
    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :verbose, :type => :boolean, :default => false,
           :desc => 'Whether the output should be verbose.'
    desc 'instantiate',
         'Create a configuration instance in the current machine.'
    def instantiate
      # Before instantiation.
      paths = prepare_storage(options.fizzy_dir,
                              :valid_inst    => false,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cfg_vars, options.vars_name)

      meta = get_meta(
        paths.cfg_meta, paths.cfg_vars, paths.tmp, paths.cfg, options.verbose)

      info 'meta: ', "#{set_color(meta['elems'].count, :green)}/#{meta['all_elems_count']} elem(s) selected."
      info 'meta: ', "#{set_color(meta['excluded_files'].count, :red)}/#{meta['all_files.count']} file(s) excluded."
      say

      # Create a configuration instance.
      say "Creating a configuration instance named `#{options.inst_name}` " +
          "from: `#{paths.cfg}`.", :blue

      exclude_pattern = /\.git|README/
      meta['excluded_files'].each do |excluded_file|
        exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
      end

      begin
        directory(paths.cfg, paths.cur_inst, :exclude_pattern => exclude_pattern)
      rescue SyntaxError
        error "Error while processing the template: `#{$fizzy_cur_template}`."
      end

      # After instantiation.
      say "Created the configuration instance in: `#{paths.cur_inst}`.", :green
    end

    def self.source_root; '/' end

  end # }}}

  class Sys < Thor # {{{

    include Fizzy::Utils

    option :vars_name, :required => true,
           :desc => 'The name for the variables file to be used.'
    option :inst_name, :required => true,
           :desc => 'The name for the new configuration instance.'
    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :run_mode, :default => 'normal',
           :enum => ['normal', 'paranoid', 'dry'],
           :desc => 'Ask confirmation for each filesystem operation.'
    option :verbose, :type => :boolean, :default => false,
           :desc => 'If the output should be verbose.'
    desc 'install',
         'Install the current configuration instance in the system.'
    def install
      # Prepare stuff for performing install.
      @run_mode = options.run_mode.to_sym
      paths = prepare_storage(options.fizzy_dir,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cur_inst_vars, options.vars_name)

      meta = get_meta(
        paths.cur_inst_meta, paths.cur_inst_vars,
        paths.tmp, paths.cur_inst, options.verbose)

      # Install the instance into the system.
      say "Installing the configuration instance `#{options.inst_name}` " +
          "into the system.", :blue
      FileUtils.cd(paths.tmp) do # stay in a safe place
        meta['elems'].each do |elem|
          say "Installing element: `#{elem['name']}`.", :cyan
          appliers.each { |applier| applier.call(elem) }
          if elem['notes']
            say "Notes for `#{elem['name']}`:", :yellow
            say elem['notes'].split("\n").collect { |s|
              "  #{s}"
            }.join("\n")
          end
        end
      end

      # Inform the user about installation status.
      say "The configuration instance `#{options.inst_name}` has been installed into the system", :green
    end

    protected

    ##
    # Return a list of functions capable to apply modifications on the system
    # based on the current configuration instance.
    #
    # In particular, an applier work for each element installed.
    #
    def appliers
      [ lambda { |elem| # Create parent directories.
          elem['fs_maps'].each do |m|
            parent_dir = File.dirname(m['dst_path'])
            if elem.has_key?('perms')
              l_ex_dir_path = f_noex_dir_path = parent_dir
              while !File.directory?(l_ex_dir_path)
                f_noex_dir_path = l_ex_dir_path
                l_ex_dir_path   = File.dirname(l_ex_dir_path)
              end
            else
              l_ex_dir_path = f_noex_dir_path = nil
            end
            # From here, we have the following variable set:
            # - `l_ex_dir_path`: Longest path prefix which points to an existing dir.
            # - `f_noex_dir_path`: Path of the first directory after the prefix which points to an existing dir.
            if !File.directory?(parent_dir)
              exec_cmd("mkdir -p \"#{parent_dir}\"",
                       :as_su => !existing_dir(parent_dir))
              if elem.has_key?('perms') && (l_ex_dir_path != f_noex_dir_path)
                exec_cmd("chmod -R \"#{elem['perms']}\" \"#{f_noex_dir_path}\"",
                         :as_su => !File.owned?(f_noex_dir_path))
              end
            end
          end
        },
        lambda { |elem| # Create a (symbolic) link for each elements' `src_path`.
          elem['fs_maps'].each do |m|
            cmd = "ln -s \"#{m['src_path']}\" \"#{m['dst_path']}\""
            if File.file?(m['dst_path'])
              warning "Skipping `#{m['dst_path']}`: already exists."
            else
              exec_cmd(cmd,
                       :as_su => !existing_dir(File.dirname(m['dst_path'])))
            end
          end
        }
      ]
    end

  end # }}}

  # }}}


  class Main < Thor # {{{

    include Fizzy::Utils

    desc 'cfg SUBCOMMAND ...ARGS',
         'Manage the Fizzy configuration (without modifying the host system).'
    subcommand 'cfg', Cfg

    desc 'sys SUBCOMMAND ...ARGS',
         'Manage the system integration with the available Fizzy configuration'
    subcommand 'sys', Sys

    desc 'usage', 'Show how to use Fizzy.'
    def usage
      url = 'https://raw.githubusercontent.com/alem0lars/fizzy/master/README.md'
      res = Net::HTTP.get_response(URI(url))
      if res.is_a?(Net::HTTPSuccess)
        say "\n#{res.body}\n"
      else
        error "Network error: cannot retrieve `#{url}`."
      end
    end

  end # }}}

end


# entry point
Fizzy::Main.start(ARGV)

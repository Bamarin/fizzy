#!/usr/bin/env ruby
#
###############################################################################
#                                                                             #
# File informations:                                                          #
# - Name:    fizzy                                                            #
# - Summary: the script for invoking fizzy commands                           #
# - Authors:                                                                  #
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             #
#   Except:                                                                   #
#   - Hash#deep_merge:                                                        #
#     - From: http://www.ruby-forum.com/topic/142809                          #
#     - Author: Stefan Rusterholz                                             #
# - Thanks to:                                                                #
#   - Luca Molari <molari.luca@gmail.com> (lmolr) for general support         #
#                                                                             #
# Project informations:                                                       #
#   - Homepage:        https://github.com/alem0lars/fizzy                     #
#   - Getting started: see README.md in the project root folder               #
#                                                                             #
# License: Apache v2.0 (see below)                                            #
#                                                                             #
###############################################################################
#                                                                             #
# Licensed to the Apache Software Foundation (ASF) under one more contributor #
# license agreements.  See the NOTICE file distributed with this work for     #
# additional information regarding copyright ownership. The ASF licenses this #
# file to you under the Apache License, Version 2.0 (the "License"); you may  #
# not use this file except in compliance with the License.                    #
# You may obtain a copy of the License at                                     #
#                                                                             #
#   http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                             #
# Unless required by applicable law or agreed to in writing, software         #
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   #
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            #
# See the License for the specific language governing permissions and         #
# limitations under the License.                                              #
#                                                                             #
###############################################################################


# requires {{{

require 'fileutils'
require 'find'
require 'ostruct'
require 'net/http'
require 'pathname'
require 'yaml'
# TMP (debug) {{{
require 'ap'
# }}}

begin
  require 'thor'
rescue
  puts '[error] thor is not installed'
  exit(-1)
end

# }}}


# ruby classes extensions {{{

class Hash
  def deep_merge(second)
    merger = proc do |key,v1,v2|
      Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2
    end
    self.merge(second, &merger)
  end
end

# }}}


module Fizzy

  module Utils # {{{

    # git {{{

    def git_info(git_root_path)
      info = nil
      FileUtils.cd(git_root_path) do
        info = {
          :local  => `git rev-parse @`.strip,
          :remote => `git rev-parse @{u}`.strip,
          :base   => `git merge-base @ @{u}`.strip
        }
      end
      info
    end

    def git_local_changes(git_root_path)
      `git status -uall --porcelain`.strip
    end

    def git_has_local_changes(git_root_path)
      !git_local_changes(git_root_path).empty?
    end

    def git_should_pull(git_root_path)
      info = git_info(git_root_path)
      info[:remote] != info[:base]
    end

    def git_should_push(git_root_path)
      info = git_info(git_root_path)
      info[:local] != info[:base]
    end

    # }}}

    # meta {{{

    ## Make sure you call setup_vars before calling this method.
    def get_meta(meta_path, tmp_path, elems_base_path)
      erb_excluded_fields = ['only']

      meta = YAML.load(File.read(meta_path))
      say "meta: processing #{meta['elems'].count} elem(s)."

      meta['elems'] = meta['elems'].each_with_index.collect do |elem, idx|
        elem_identifier = elem['name'] || "src:'#{elem['src']}'"

        # 1: validate 'only' and determine if the element is selected.
        if elem.has_key?('only') && !elem['only'].is_a?(Hash)
          error("elem '#{elem_identifier}' has invalid 'only': it's not an hash")
        end
        unless elem.has_key?('only')
          selected = true
          #say "elem '#{elem_identifier}' selected (no 'only')."
        else
          only = elem['only']
          wants_features = only.has_key?('features')
          wants_vars = only.has_key?('vars')
          selected = !wants_features && !wants_vars
          selected ||= wants_features &&
                        only['features'].any? { |f| has_feature? f }
          selected ||= wants_vars &&
                       only['vars'].any? { |v| get_var v }
          if selected
            #say "elem '#{elem_identifier} selected (by 'only')."
          end
        end

        # 2: pre-process strings with ERB
        if selected
          elem.each do |k, v|
            unless erb_excluded_fields.include? k
              elem[k] = ERB.new(v).result(binding)
            end
          end
        end

        # 3: validate and normalize 'name', 'src', 'dst'
        if selected
          unless elem.has_key?('src')
            error("elem '#{elem_identifier}' doesn't contain 'src'")
          end
          unless elem.has_key?('name')
            elem['name'] = elem['src']
          end
          unless elem.has_key?('dst')
            error("elem '#{elem_identifier}' doesn't contain 'dst'")
          end
        end

        next unless selected
        elem
      end.compact!
      say "meta: #{meta['elems'].count} elem(s) enabled."

      FileUtils.cd(tmp_path) do # stay in a safe place

        # for each active elem, match the 'src' field  against the filesystem
        # and determine src / dst paths.
        meta['elems'].each do |elem|
          found = false

          Find.find(elems_base_path).each do |subfile_path|
            subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
              Pathname.new(elems_base_path)).to_s
            if md = Regexp.new(elem['src']).match(subfile_rel_path)
              found = true
              dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
                idx = Integer($1)
                unless (1..md.length) === idx
                  error("invalid 'dst' for elem '#{elem['name']}': nothing " +
                        "captured at index '#{idx}'")
                else
                  md[idx]
                end
              end
              elem.merge!({
                'src_path' => subfile_path,
                'dst_path' => dst_path
              })
            end
          end

          unless found
            warning "inconsistency found for elem '#{elem['name']}': no file matches src: '#{elem['src']}'."
          end

        end

        # build the list of excluded files (needed by thor's `directory()`)
        src_paths = Set.new(meta['elems'].collect { |elem| elem['src_path'] })
        all_paths = Set.new(Find.find(elems_base_path))
        meta['excluded_files'] = all_paths - src_paths
        say "meta: #{meta['excluded_files'].count} file(s) excluded."
      end

      #ap meta['elems']
      meta
    end

    # }}}

    # vars {{{

    attr_reader :vars

    def setup_vars(vars_path, vars_file_name)
      vars = {}
      dummy_names_regex = /none|nothing/i
      inherits_regex = /#=>\s*inherits:\s*(?<inherits_name>[^\s]+)\s*<=#/i

      read_vars_file = lambda do |file_name|
        file_path = File.join(vars_path, "#{file_name}.yml")
        file_content = File.read(file_path)

        # find the name of the file to be inherited
        inherits_name = file_content.match(inherits_regex)[:inherits_name]

        # load the file that should be inherited (if any) by calling this
        # function recursively and merging the read variables into `vars`
        if inherits_name && !(inherits_name =~ dummy_names_regex)
          inherits_file_path = File.join(vars_path, "#{inherits_name}.yml")
          unless File.file?(inherits_file_path)
            error("inherited vars file doesn't exist: '#{inherits_name}'")
          end
          vars = vars.deep_merge(read_vars_file.call(inherits_name))
        end

        # base case: read the yaml file (parsing possible erb template
        # icecreams) and store the read variables into `vars`
        vars = vars.deep_merge(YAML.load(ERB.new(file_content).result) || {})
      end

      read_vars_file.call(vars_file_name)

      @vars = vars
    end

    def get_var(var_name)
      dot_split_regexp = /([^.]+)(?:\.|$)/
      var_name.to_s
          .scan(dot_split_regexp).map { |match_group| match_group[0] }
          .reject(&:empty?)
          .inject(vars) do |cur_obj, name_component|

        nxt_obj = if cur_obj.has_key?(name_component)
          cur_obj[name_component]
        else
          nil
        end
        nxt_obj or break nil
      end
    end

    def get_var!(var_name)
      get_var(var_name) or raise "undefined or `nil` variable: '#{var_name}'"
    end

    def has_feature?(feature_name)
      get_var!('features').include? feature_name.to_s
    end

    # }}}

    # env / host system {{{

    def get_env(envvar_name)
      ENV[envvar_name.to_s]
    end

    def get_env!(envvar_name)
      get_env(envvar_name) or
        raise "undefined environment variable: '#{envvar_name}'"
    end

    def is_osx?
      RUBY_PLATFORM =~ /darwin$/
    end

    def is_linux?
      RUBY_PLATFORM =~ /-linux$/
    end

    # }}}

    # commands {{{

    def exec_cmd(cmd, as_su: false)
      full_cmd = as_su ? "sudo #{cmd}" : cmd

      really_run = case @run_mode
                   when :normal
                     true
                   when :paranoid
                     quiz("Do you want to run: '#{full_cmd}'")
                   when :dry
                     false
                   else
                     true
                   end

      if really_run || @run_mode == :dry
        if as_su
          say "[sudo] #{cmd}", :magenta
        else
          say cmd, :magenta
        end
      end

      if really_run
        system(full_cmd)
      end
    end

    # }}}

    # filesystem {{{

    def existing_dir(path, writable: true)
      dir_path = path
      while !File.directory?(dir_path)
        dir_path = File.dirname(dir_path)
      end
      (writable && !File.writable?(dir_path)) ? nil : dir_path
    end

    def prepare_storage(root_path, valid_cfg: true, valid_inst: true, cur_inst_name: nil)
      # paths based on internal conventions
      parent_path        = File.expand_path(File.dirname(root_path))
      tmp_path           = File.join(root_path, 'tmp')

      cfg_path           = File.join(root_path, 'cfg')
      cfg_vars_path      = File.join(cfg_path,  'vars')
      cfg_meta_path      = File.join(cfg_path,  'meta.yml')

      inst_path          = File.join(root_path, 'inst')
      cur_inst_path      = cur_inst_name && File.join(inst_path, cur_inst_name)
      cur_inst_vars_path = cur_inst_path && File.join(cur_inst_path, 'vars')
      cur_inst_meta_path = cur_inst_path && File.join(cur_inst_path, 'meta.yml')

      # validate storage correctness
      if ((File.directory?(root_path)  && !File.writable?(root_path)) ||
          File.file?(root_path)                                       ||
          (!File.directory?(root_path) && !File.writable?(parent_path)))
        error("no write perms in fizzy storage: #{root_path}")
      end
      if ((File.directory?(tmp_path) && !File.writable?(tmp_path)) ||
          File.file?(tmp_path))
        error('tmp dir already exists but is not writable')
      end
      if valid_cfg
        if !File.directory?(root_path)
          error("fizzy root directory doesn't exist (maybe you need to run: `fizzy cfg sync`)")
        end
        if !File.directory?(cfg_path) || !File.writable?(cfg_path)
          error('config dir already exists but is not writable')
        end
        if !File.file?(cfg_meta_path)
          error("config is invalid: '#{cfg_meta_path}' isn't a valid meta file")
        end
        if !File.directory?(cfg_vars_path)
          error("invalid vars directory: '#{cfg_vars_path}' doesn't exist")
        end
      end
      if valid_inst
        if !File.directory?(root_path)
          error("fizzy root directory doesn't exist (maybe you need to run: `fizzy cfg sync`)")
        end
        if !File.directory?(cur_inst_path) || !File.writable?(cur_inst_path)
          error('instance dir already exists but is not writable')
        end
        if !File.file?(cur_inst_meta_path)
          error("instance is invalid: '#{cur_inst_meta_path}' isn't a valid meta file")
        end
        if !File.directory?(cur_inst_vars_path)
          error("invalid vars directory: '#{cur_inst_vars_path}' doesn't exist")
        end
      end

      # create non-existing internal directories
      FileUtils.mkdir_p(root_path) unless File.directory?(root_path)
      FileUtils.mkdir_p(tmp_path)  unless File.directory?(tmp_path)
      FileUtils.mkdir_p(inst_path) unless File.directory?(inst_path)
      FileUtils.mkdir_p(cur_inst_path) if cur_inst_path && !File.directory?(cur_inst_path)

      # return the known storage paths
      OpenStruct.new(
        :root          => root_path,
        :tmp           => tmp_path,
        :cfg           => cfg_path,
        :cfg_vars      => cfg_vars_path,
        :cfg_meta      => cfg_meta_path,
        :inst          => inst_path,
        :cur_inst      => cur_inst_path,
        :cur_inst_vars => cur_inst_vars_path,
        :cur_inst_meta => cur_inst_meta_path)
    end

    # }}}

    # I/O & error handling {{{

    def quiz(question, type: :bool)
      answer = ask "#{question.strip}? ", :magenta
      case type
      when :bool
        if answer =~ /y|ye|yes|yeah|ofc/i
          true
        elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
          false
        else
          say 'answer misunderstood', :yellow
          quiz(question, :type => type)
        end
      when :string
        if answer.empty?
          say 'empty answer', :yellow
          quiz(question, :type => type)
        else
          answer
        end
      else
        error("unhandled question type: '#{type}'")
      end
    end

    def warning(msg)
      say msg, :yellow
      exit(-1) unless quiz('continue')
    end

    def error(msg)
      say msg, :red
      exit(-1)
    end

    # }}}

  end # }}}


  # subcommands {{{

  class Cfg < Thor # {{{

    include Thor::Actions
    include Fizzy::Utils

    desc 'add', 'add a new configuration'
    def add

    end

    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'edit CFG_NAME', 'find the files relative to CFG_NAME and edit them'
    def edit(cfg_name)
      # before edit
      paths = prepare_storage(options.fizzy_dir, :valid_inst => false)
      find_path = File.join(paths.cfg, cfg_name)
      cfg_files_arg = (File.exist?(find_path) ?
          find_path :
          Dir.glob("#{find_path}*", File::FNM_DOTMATCH).to_a.delete_if { |elem|
            elem =~ /\.git/
          }.join(' ')
      ).strip
      editor = ENV['EDITOR'] || 'vim'

      # perform edit
      if cfg_files_arg.empty?
        say "no files matching '#{cfg_name}' have been found", :yellow
        status = nil
      else
        say "editing: '#{cfg_files_arg}'", :cyan
        status = system("#{editor} #{cfg_files_arg}")
      end

      # after edit
      if status
        say "successfully edited: '#{cfg_files_arg}'", :green
      elsif status.nil?
        say 'editing skipped', :yellow
      else
        say "failed to edit: '#{cfg_files_arg}'", :red
      end
    end

    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    option :url, :default => nil,
           :desc => 'the url to the repository holding config (suppored: git)'
    desc 'sync', 'synchronize the remote repository with the local one'
    def sync
      # before sync
      paths = prepare_storage(options.fizzy_dir,
                              :valid_cfg => false, :valid_inst => false)

      # perform sync
      sync_result = if File.directory?(paths.cfg)
        say 'syncing from origin', :blue
        status = nil
        FileUtils.cd(paths.cfg) do
          # fetch
          say 'fetching informations from origin', :cyan
          status = system('git fetch origin')
          # (optional) commit
          if status && git_has_local_changes(paths.cfg)
            say 'the configuration has the following local changes:', :cyan
            say git_local_changes(paths.cfg)
            should_commit = quiz 'do you want to commit them'
            if should_commit
              commit_msg = quiz 'commit message', :type => :string
              status = system('git add -A')
              status &&= system("git commit -am \"#{commit_msg}\"")
            else
              status = false
            end
          end
          # (optional) pull
          if status && git_should_pull(paths.cfg)
            say 'performing pull', :cyan
            status = system('git pull origin master')
            status &&= system('git submodule foreach git checkout master')
            status &&= system('git submodule foreach git merge origin/master')
          end
          # (optional) push
          if status && git_should_push(paths.cfg)
            say 'performing push', :cyan
            status = system('git push origin master')
          end
        end
        status
      else
        say "syncing from remote repo: '#{options.url}'", :blue
        error('invalid url option') if options.url.nil?
        system("git clone --recursive #{options.url} #{paths.cfg}")
      end

      # after sync
      if sync_result
        say "synced to: #{paths.cfg}", :green
      else
        error('unable to sync')
      end
    end

    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'instantiate', 'create a configuration instance in the current machine'
    def instantiate
      # before instantiation
      paths = prepare_storage(options.fizzy_dir,
                              :valid_inst    => false,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cfg_vars, options.vars_name)

      meta = get_meta(paths.cfg_meta, paths.tmp, paths.cfg)

      # create a configuration instance
      say "creating a configuration instance named '#{options.inst_name}' " +
          "from: #{paths.cfg}", :blue

      exclude_pattern = /\.git|README/
      meta['excluded_files'].each do |excluded_file|
        exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
      end

      directory(paths.cfg, paths.cur_inst, :exclude_pattern => exclude_pattern)

      # after instantiation
      say "created the configuration instance in: #{paths.cur_inst}", :green
    end

    def self.source_root; '/' end

  end # }}}

  class Sys < Thor # {{{

    include Fizzy::Utils

    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    option :run_mode, :default => 'normal',
           :enum => ['normal', 'paranoid', 'dry'],
           :desc => 'ask confirmation for each filesystem operation'
    desc 'install',
         'install the current configuration instance in the system'
    def install
      @run_mode = options.run_mode.to_sym

      # before install
      paths = prepare_storage(options.fizzy_dir,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cur_inst_vars, options.vars_name)

      meta = get_meta(paths.cur_inst_meta, paths.tmp, paths.cur_inst)

      # perform install
      say "installing the configuration instance '#{options.inst_name}' " +
          "into the system", :blue
      FileUtils.cd(paths.tmp) do # stay in a safe place
        enabled_elems(meta['elems'], get_var!('features')).each do |elem|
          say "installing elem: '#{elem['name']}'", :cyan
          appliers.each { |applier| applier.call(elem) }
          if elem['notes']
            say "notes for '#{elem['name']}:", :yellow
            say elem['notes']
          end
        end
      end

      # after instantiation
      say 'the configuration instance has been installed into the system', :green
    end

    protected

    ##
    # return a list of functions capable to apply modifications on the system
    # based on the current configuration instance
    #
    # in particular, an applier work for each element installed
    #
    def appliers
      [ lambda { |elem| # mkdir parent directories
          parent_dir = File.dirname(elem['dst_path'])
          if elem.has_key?('perms')
            l_ex_dir_path = f_noex_dir_path = parent_dir
            while !File.directory?(l_ex_dir_path)
              f_noex_dir_path = l_ex_dir_path
              l_ex_dir_path   = File.dirname(l_ex_dir_path)
            end
          else
            l_ex_dir_path = f_noex_dir_path = nil
          end
          if !File.directory?(parent_dir)
            exec_cmd("mkdir -p \"#{parent_dir}\"",
                     :as_su => !existing_dir(parent_dir))
            if elem.has_key?('perms') && (l_ex_dir_path != f_noex_dir_path)
              ask_exec_cmd("chmod -R \"#{elem['perms']}\" \"#{f_noex_dir_path}\"",
                       :as_su => !File.owned?(f_noex_dir_path))
            end
          end
        },
        lambda { |elem| # create link
          cmd = "ln -s \"#{elem['src_path']}\" \"#{elem['dst_path']}\""
          if File.file?(elem['dst_path'])
            say "skipping '#{elem['dst_path']}': already exists", :yellow
          else
            exec_cmd(cmd,
                     :as_su => !existing_dir(File.dirname(elem['dst_path'])))
          end
        }
      ]
    end

  end # }}}

  # }}}


  class Main < Thor # {{{

    include Fizzy::Utils

    desc 'cfg SUBCOMMAND ...ARGS',
         'manage the fizzy configuration'
    subcommand 'cfg', Cfg

    desc 'sys SUBCOMMAND ...ARGS',
         'manage the system integration with the available fizzy configuration'
    subcommand 'sys', Sys

    desc 'usage', 'show how to use fizzy'
    def usage
      url = 'https://raw.githubusercontent.com/alem0lars/fizzy/master/README.md'
      res = Net::HTTP.get_response(URI(url))
      if res.is_a?(Net::HTTPSuccess)
        puts "\n#{res.body}\n"
      else
        puts "network error: cannot retrieve '#{url}'"
      end
    end

  end # }}}

end


# entry point
Fizzy::Main.start(ARGV)

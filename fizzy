#!/usr/bin/env ruby
#
###############################################################################
#                                                                             #
# File informations:                                                          #
# - Name:    fizzy                                                            #
# - Summary: the script for invoking fizzy commands                           #
# - Authors:                                                                  #
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             #
#   Except:                                                                   #
#   - Hash#deep_merge:                                                        #
#     - From: http://www.ruby-forum.com/topic/142809                          #
#     - Author: Stefan Rusterholz                                             #
# - Thanks to:                                                                #
#   - Luca Molari <molari.luca@gmail.com> (lmolr) for general support         #
#                                                                             #
# Project informations:                                                       #
#   - Homepage:        https://github.com/alem0lars/fizzy                     #
#   - Getting started: see README.md in the project root folder               #
#                                                                             #
# License: Apache v2.0 (see below)                                            #
#                                                                             #
###############################################################################
#                                                                             #
# Licensed to the Apache Software Foundation (ASF) under one more contributor #
# license agreements.  See the NOTICE file distributed with this work for     #
# additional information regarding copyright ownership. The ASF licenses this #
# file to you under the Apache License, Version 2.0 (the "License"); you may  #
# not use this file except in compliance with the License.                    #
# You may obtain a copy of the License at                                     #
#                                                                             #
#   http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                             #
# Unless required by applicable law or agreed to in writing, software         #
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   #
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            #
# See the License for the specific language governing permissions and         #
# limitations under the License.                                              #
#                                                                             #
###############################################################################


# requires {{{

require 'fileutils'
require 'find'
require 'ostruct'
require 'net/http'
require 'pathname'
require 'yaml'

begin
  require 'thor'
rescue
  puts '[error] thor is not installed'
  exit(-1)
end

# }}}


# ruby classes extensions {{{

class Hash
  def deep_merge(second)
    merger = proc do |key,v1,v2|
      Hash === v1 && Hash === v2 ? v1.merge(v2, &merger) : v2
    end
    self.merge(second, &merger)
  end
end

# }}}


module Fizzy

  module Utils # {{{

    # git {{{

    def git_info(git_root_path)
      info = nil
      FileUtils.cd(git_root_path) do
        info = {
          :local  => `git rev-parse @`.strip,
          :remote => `git rev-parse @{u}`.strip,
          :base   => `git merge-base @ @{u}`.strip
        }
      end
      info
    end

    def git_local_changes(git_root_path)
      `git status -uall --porcelain`.strip
    end

    def git_has_local_changes(git_root_path)
      !git_local_changes(git_root_path).empty?
    end

    def git_should_pull(git_root_path)
      info = git_info(git_root_path)
      info[:remote] != info[:base]
    end

    def git_should_push(git_root_path)
      info = git_info(git_root_path)
      info[:local] != info[:base]
    end

    # }}}

    # meta {{{

    def get_meta(meta_path)
      meta = YAML.load(ERB.new(File.read(meta_path)).result)
      error("invalid meta: 'elems' key not found") unless meta.has_key?('elems')
      unless meta['elems'].respond_to?(:each_with_index)
        error("invalid meta: 'elems' is not iterable")
      end
      meta['elems'].each_with_index do |elem, idx|
        error("elem '#{idx}' isn't a hash") unless elem.is_a?(Hash)
        unless elem.has_key?('src')
          error("elem '#{elem['name'] || "idx=#{idx}"}' doesn't contain 'src'")
        end
        unless elem.has_key?('name')
          elem['name'] = elem['src']
        end
        unless elem.has_key?('dst')
          error("elem '#{elem['name']}' doesn't contain 'dst'")
        end
        if elem.has_key?('only') && !elem['only'].is_a?(Array)
          error("elem '#{elem['name']}' has invalid 'only': it's not an array")
        end
      end
      meta
    end

    # }}}

    # elems {{{

    def enabled_elems(elems, features)
      elems.select { |elem| enabled_elem?(elems, features) }
    end

    def excluded_elems(elems, features)
      elems.reject { |elem| enabled_elem?(elems, features) }
    end

    def enabled_elem?(elem, features)
      !elem.has_key?('only') || elem['only'].any? { |o| features.include?(o) }
    end

    # }}}

    # vars {{{

    attr_reader :vars

    def setup_vars(vars_path, vars_file_name)
      vars = {}
      dummy_names_regex = /none|nothing/i
      inherits_regex = /#=>\s*inherits:\s*(?<inherits_name>[^\s]+)\s*<=#/i

      read_vars_file = lambda do |file_name|
        file_path = File.join(vars_path, "#{file_name}.yml")
        file_content = File.read(file_path)

        # find the name of the file to be inherited
        inherits_name = file_content.match(inherits_regex)[:inherits_name]

        # load the file that should be inherited (if any) by calling this
        # function recursively and merging the read variables into `vars`
        if inherits_name && (inherits_name =~ dummy_names_regex)
          inherits_file_path = File.join(vars_path, "#{inherits_name}.yml")
          unless File.file?(inherits_file_path)
            error("inherited vars file doesn't exist: '#{inherits_name}'")
          end
          vars = vars.deep_merge(read_vars_file.call(inherits_name))
        end

        # base case: read the yaml file (parsing possible erb template
        # icecreams) and store the read variables into `vars`
        vars = vars.deep_merge(YAML.load(ERB.new(file_content).result) || {})
      end

      read_vars_file.call(vars_file_name)

      @vars = OpenStruct.new(vars)
    end

    # }}}

    # commands {{{

    def exec_cmd(cmd, as_su: false)
      if as_su
        say "[sudo] #{cmd}", :magenta
      else
        say cmd, :magenta
      end
      system(as_su ? "sudo #{cmd}" : cmd)
    end

    # }}}

    # filesystem {{{

    def existing_dir(path, writable: true)
      dir_path = path
      while !File.directory?(dir_path)
        dir_path = File.dirname(dir_path)
      end
      (writable && !File.writable?(dir_path)) ? nil : dir_path
    end

    def prepare_storage(root_path, valid_cfg: true, valid_inst: true, cur_inst_name: nil)
      # paths based on internal conventions
      parent_path    = File.expand_path(File.dirname(root_path))
      tmp_path       = File.join(root_path, 'tmp')
      cfg_path       = File.join(root_path, 'cfg')
      cfg_vars_path  = File.join(cfg_path,  'vars')
      cfg_meta_path  = File.join(cfg_path,  'meta.yml')
      inst_path      = File.join(root_path, 'inst')
      inst_vars_path = File.join(inst_path, 'vars')
      inst_meta_path = File.join(inst_path, 'meta.yml')

      # validate storage correctness
      if ((File.directory?(root_path)  && !File.writable?(root_path)) ||
          File.file?(root_path)                                       ||
          (!File.directory?(root_path) && !File.writable?(parent_path)))
        error("no write perms in fizzy storage: #{root_path}")
      end
      if ((File.directory?(tmp_path) && !File.writable?(tmp_path)) ||
          File.file?(tmp_path))
        error('tmp dir already exists but is not writable')
      end
      if valid_cfg
        if !File.directory?(cfg_path) || !File.writable?(cfg_path)
          error('config dir already exists but is not writable')
        end
        if !File.file?(cfg_meta_path)
          error("config is invalid: '#{cfg_meta_path}' isn't a valid meta file")
        end
        if !File.directory?(cfg_vars_path)
          error("invalid vars directory: '#{cfg_vars_path}' doesn't exist")
        end
      end
      if valid_inst
        if !File.directory?(inst_path) || !File.writable?(inst_path)
          error('instance dir already exists but is not writable')
        end
        if !File.file?(inst_meta_path)
          error("instance is invalid: '#{inst_meta_path}' isn't a valid meta file")
        end
        if !File.directory?(inst_vars_path)
          error("invalid vars directory: '#{inst_vars_path}' doesn't exist")
        end
      end

      # create non-existing internal directories
      FileUtils.mkdir_p(root_path) unless File.directory?(root_path)
      FileUtils.mkdir_p(tmp_path)  unless File.directory?(tmp_path)
      FileUtils.mkdir_p(inst_path) unless File.directory?(inst_path)

      # return the known storage paths
      OpenStruct.new(
        :root      => root_path,
        :tmp       => tmp_path,
        :cfg       => cfg_path,
        :cfg_vars  => cfg_vars_path,
        :cfg_meta  => cfg_meta_path,
        :inst      => inst_path,
        :inst_vars => inst_vars_path,
        :inst_meta => inst_meta_path,
        :cur_inst  => cur_inst_name ? File.join(inst_path, cur_inst_name) : nil)
    end

    # }}}

    # I/O & error handling {{{

    def quiz(question, type: :bool)
      answer = ask "#{question.strip}? ", :magenta
      case type
      when :bool
        if answer =~ /y|ye|yes|yeah|ofc/i
          true
        elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
          false
        else
          say 'answer misunderstood', :yellow
          quiz(question, :type => type)
        end
      when :string
        if answer.empty?
          say 'empty answer', :yellow
          quiz(question, :type => type)
        else
          answer
        end
      else
        error("unhandled question type: '#{type}'")
      end
    end

    def error(msg)
      say msg, :red
      exit(-1)
    end

    # }}}

  end # }}}


  # subcommands {{{

  class Cfg < Thor # {{{

    include Thor::Actions
    include Fizzy::Utils

    desc 'add', 'add a new configuration'
    def add

    end

    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'edit CFG_NAME', 'find the files relative to CFG_NAME and edit them'
    def edit(cfg_name)
      # before edit
      paths = prepare_storage(options.fizzy_dir, :valid_inst => false)
      find_path = File.join(paths.cfg, cfg_name)
      cfg_files_arg = (File.exist?(find_path) ?
          find_path :
          Dir.glob("#{find_path}*", File::FNM_DOTMATCH).to_a.delete_if { |elem|
            elem =~ /\.git/
          }.join(' ')
      ).strip
      editor = ENV['EDITOR'] || 'vim'

      # perform edit
      if cfg_files_arg.empty?
        say "no files matching '#{cfg_name}' have been found", :yellow
        status = nil
      else
        say "editing: '#{cfg_files_arg}'", :cyan
        status = system("#{editor} #{cfg_files_arg}")
      end

      # after edit
      if status
        say "successfully edited: '#{cfg_files_arg}'", :green
      elsif status.nil?
        say 'editing skipped', :yellow
      else
        say "failed to edit: '#{cfg_files_arg}'", :red
      end
    end

    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    option :url, :default => nil,
           :desc => 'the url to the repository holding config (suppored: git)'
    desc 'sync', 'synchronize the remote repository with the local one'
    def sync
      # before sync
      paths = prepare_storage(options.fizzy_dir,
                              :valid_cfg => false, :valid_inst => false)

      # perform sync
      sync_result = if File.directory?(paths.cfg)
        say 'syncing from origin', :blue
        status = nil
        FileUtils.cd(paths.cfg) do
          # fetch
          say 'fetching informations from origin', :cyan
          status = system('git fetch origin')
          # (optional) commit
          if status && git_has_local_changes(paths.cfg)
            say 'the configuration has the following local changes:', :cyan
            say git_local_changes(paths.cfg)
            should_commit = quiz 'do you want to commit them'
            if should_commit
              commit_msg = quiz 'commit message', :type => :string
              status = system('git add -A')
              status &&= system("git commit -am \"#{commit_msg}\"")
            else
              status = false
            end
          end
          # (optional) pull
          if status && git_should_pull(paths.cfg)
            say 'performing pull', :cyan
            status = system('git pull origin master')
          end
          # (optional) push
          if status && git_should_push(paths.cfg)
            say 'performing push', :cyan
            status = system('git push origin master')
          end
        end
        status
      else
        say "syncing from remote repo: '#{options.url}'", :blue
        error('invalid url option') if options.url.nil?
        system("git clone #{options.url} #{paths.cfg}")
      end

      # after sync
      if sync_result
        say "synced to: #{paths.cfg}", :green
      else
        error('unable to sync')
      end
    end

    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'instantiate', 'create a configuration instance in the current machine'
    def instantiate
      # before instantiation
      paths = prepare_storage(options.fizzy_dir,
                              :valid_inst    => false,
                              :cur_inst_name => options.inst_name)
      meta = get_meta(paths.cfg_meta)
      meta['elems'] = normalize_elems(meta, paths)

      # create a configuration instance
      setup_vars(paths.cfg_vars, options.vars_name)
      say "creating a configuration instance named '#{options.inst_name}' " +
          "from: #{paths.cfg}", :blue

      exclude_pattern = /\.git|README/
      excluded_elems(meta['elems'], @vars.features).each do |excluded_elem|
        exclude_pattern = /#{exclude_pattern}|#{excluded_elem}/
      end

      directory(paths.cfg, paths.cur_inst, :exclude_pattern => exclude_pattern)

      # after instantiation
      say "created the configuration instance in: #{paths.cur_inst}", :green
    end

    def self.source_root; '/' end

  end # }}}

  class Sys < Thor # {{{

    include Fizzy::Utils

    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'install',
         'install the current configuration instance in the system'
    def install
      # before install
      paths = prepare_storage(options.fizzy_dir,
                              :cur_inst_name => options.inst_name)
      meta = get_meta(paths.inst_meta)
      meta['elems'] = normalize_elems(meta, paths)

      # perform install
      say "installing the configuration instance '#{options.inst_name}' " +
          "into the system", :blue
      setup_vars(paths.inst_vars, options.vars_name)
      FileUtils.cd(paths.tmp) do # stay in a safe place
        enabled_elems(meta['elems'], @vars.features).each do |elem|
          say "installing elem: '#{elem['name']}'", :cyan
          appliers.each { |applier| applier.call(elem) }
          if elem['notes']
            say "notes for '#{elem['name']}:", :yellow
            say elem['notes']
          end
        end
      end

      # after instantiation
      say 'the configuration instance has been installed into the system', :green
    end

    protected

    def normalize_elems(meta, paths)
      elems = []
      FileUtils.cd(paths.tmp) do # stay in a safe place
        Find.find(paths.cur_inst).each do |subfile_path|
          subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
              Pathname.new(paths.cur_inst)).to_s
          meta['elems'].each do |elem|
            if md = Regexp.new(elem['src']).match(subfile_rel_path)
              dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
                idx = Integer($1)
                unless (1..md.length) === idx
                  error("invalid 'dst' for elem '#{elem['name']}': nothing " +
                        "captured at index '#{idx}'")
                else
                  md[idx]
                end
              end
              elems << elem.merge({
                'src_path' => subfile_path,
                'dst_path' => dst_path
              })
            end
          end
        end
      end
      elems
    end

    ##
    # return a list of functions capable to apply modifications on the system
    # based on the current configuration instance
    #
    # in particular, an applier work for each element installed
    #
    def appliers
      [ lambda { |elem| # mkdir parent directories
          parent_dir = File.dirname(elem['dst_path'])
          if elem.has_key?('perms')
            l_ex_dir_path = f_noex_dir_path = parent_dir
            while !File.directory?(l_ex_dir_path)
              f_noex_dir_path = l_ex_dir_path
              l_ex_dir_path   = File.dirname(l_ex_dir_path)
            end
          else
            l_ex_dir_path = f_noex_dir_path = nil
          end
          if !File.directory?(parent_dir)
            exec_cmd("mkdir -p \"#{parent_dir}\"",
                     :as_su => !existing_dir(parent_dir))
            if elem.has_key?('perms') && (l_ex_dir_path != f_noex_dir_path)
              exec_cmd("chmod -R \"#{elem['perms']}\" \"#{f_noex_dir_path}\"",
                       :as_su => !File.owned?(f_noex_dir_path))
            end
          end
        },
        lambda { |elem| # create link
          cmd = "ln -s \"#{elem['src_path']}\" \"#{elem['dst_path']}\""
          if File.file?(elem['dst_path'])
            say "skipping '#{elem['dst_path']}': already exists", :yellow
          else
            exec_cmd(cmd,
                     :as_su => !existing_dir(File.dirname(elem['dst_path'])))
          end
        }
      ]
    end

  end # }}}

  # }}}


  class Main < Thor # {{{

    include Fizzy::Utils

    desc 'cfg SUBCOMMAND ...ARGS',
         'manage the fizzy configuration'
    subcommand 'cfg', Cfg

    desc 'sys SUBCOMMAND ...ARGS',
         'manage the system integration with the available fizzy configuration'
    subcommand 'sys', Sys

    desc 'usage', 'show how to use fizzy'
    def usage
      url = 'https://raw.githubusercontent.com/alem0lars/fizzy/master/README.md'
      res = Net::HTTP.get_response(URI(url))
      if res.is_a?(Net::HTTPSuccess)
        puts "\n#{res.body}\n"
      else
        puts "network error: cannot retrieve '#{url}'"
      end
    end

  end # }}}

end


# entry point
Fizzy::Main.start(ARGV)

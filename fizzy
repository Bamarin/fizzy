#!/usr/bin/env ruby
# coding: utf-8
#
###############################################################################
#                                                                             #
# File informations:                                                          #
# - Name:    fizzy                                                            #
# - Summary: The script for invoking Fizzy commands                           #
# - Authors:                                                                  #
#   - Alessandro Molari <molari.alessandro@gmail.com> (alem0lars)             #
# - Contributors:                                                             #
#   - Luca Molari <molari.luca@gmail.com> (lmolr)                             #
#   Except:                                                                   #
#   - Hash#deep_merge:                                                        #
#     - From: http://www.ruby-forum.com/topic/142809                          #
#     - Author: Stefan Rusterholz                                             #
#   Thanks to:                                                                #
#   - Authors & contributors of the [thor](http://whatisthor.com/) gem        #
#     (our only dependency), in particular Yehuda Katz & Erik Michaels-Ober.  #
#                                                                             #
# Project informations:                                                       #
#   - Homepage:        https://github.com/alem0lars/fizzy                     #
#   - Getting started: see README.md in the project root folder               #
#                                                                             #
# License: Apache v2.0 (see below)                                            #
#                                                                             #
###############################################################################
#                                                                             #
# Licensed to the Apache Software Foundation (ASF) under one more contributor #
# license agreements.  See the NOTICE file distributed with this work for     #
# additional information regarding copyright ownership. The ASF licenses this #
# file to you under the Apache License, Version 2.0 (the "License"); you may  #
# not use this file except in compliance with the License.                    #
# You may obtain a copy of the License at                                     #
#                                                                             #
#   http://www.apache.org/licenses/LICENSE-2.0                                #
#                                                                             #
# Unless required by applicable law or agreed to in writing, software         #
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT   #
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.            #
# See the License for the specific language governing permissions and         #
# limitations under the License.                                              #
#                                                                             #
###############################################################################

# {{{ Requires

# {{{ Core modules.
require 'fileutils'
require 'find'
require 'ostruct'
require 'net/http'
require 'pathname'
require 'yaml'
# }}}

# {{{ Try to require `thor` or raise an exception.
begin
  require 'thor'
rescue
  puts '\e[31m☠ The gem `thor` is not installed. To install run: `gem install thor`. Aborting.\e[0m'
  exit(-1)
end
# }}}

# }}}

# {{{ Global constants

# {{{ Define platform-specific constants.
RUBY_PLATFORM_IS_OSX   = RUBY_PLATFORM =~ /darwin/
RUBY_PLATFORM_IS_LINUX = RUBY_PLATFORM =~ /linux/
# }}}

# }}}

# {{{ Configuration

# {{{ Configure the default Fizzy root directory.
$DEF_FIZZY_DIR = ENV['FIZZY_DIR']
if RUBY_PLATFORM_IS_LINUX
  $DEF_FIZZY_DIR ||= '/var/tmp/fizzy'
elsif RUBY_PLATFORM_IS_OSX
  $DEF_FIZZY_DIR ||= '~/Library/Application Support/Fizzy'
end
$DEF_FIZZY_DIR = File.expand_path($DEF_FIZZY_DIR)
# }}}

# {{{ Configure the default editor (this is the last fallback).
$DEF_EDITOR = 'vim'
# }}}

# }}}

# {{{ Ruby classes extensions

class Thor
  module Actions
    # {{{ Monkey-patch to retrieve the template currently processed.
    old_template = instance_method(:template)
    define_method :template, ->(source, *args, &blk) do
      $fizzy_cur_template = source
      old_template.bind(self).(source, *args, &blk)
    end
    # }}}
  end
end

class Hash

  ##
  # Perform recursive merge of the current `Hash` (`self`) with the provided one
  # (the `second` argument).
  #
  # The merge have knows how to recurse in both `Hash`es and `Array`s.
  #
  def deep_merge(second) # {{{
    merger = proc do |key, v1, v2|
      if Hash === v1 && Hash === v2
        v1.merge(v2, &merger)
      elsif Array === v1 && Array === v2
        (Set.new(v1) + Set.new(v2)).to_a
      else
        v2
      end
    end
    self.merge(second, &merger)
  end # }}}

end

# }}}


module Fizzy

  module Utils # {{{

    # {{{ Git

    # {{{ Functions to retrieve git informations.

    def git_info(git_root_path)
      info = nil
      FileUtils.cd(git_root_path) do
        info = {
          :local  => `git rev-parse @`.strip,
          :remote => `git rev-parse @{u}`.strip,
          :base   => `git merge-base @ @{u}`.strip
        }
      end
      info
    end

    def git_local_changes(git_root_path)
      `git status -uall --porcelain`.strip
    end

    def git_has_local_changes(git_root_path)
      !git_local_changes(git_root_path).empty?
    end

    def git_should_pull(git_root_path)
      info = git_info(git_root_path)
      info[:remote] != info[:base]
    end

    def git_should_push(git_root_path)
      info = git_info(git_root_path)
      info[:local] != info[:base]
    end

    # }}}

    # {{{ Functions to perform git operations.

    def git_pull(with_submodules: true)
      say 'Performing pull.', :cyan
      status = exec_cmd('git pull origin master',
                        as_su: !existing_dir(Dir.pwd))
      if with_submodules
        status &&= exec_cmd('git submodule foreach git checkout master',
                            as_su: !existing_dir(Dir.pwd))
        status &&= exec_cmd('git submodule foreach git merge origin/master',
                            as_su: !existing_dir(Dir.pwd))
      end
      status
    end

    def git_clone(url, dst_path, recursive: true)
      say "Syncing from remote repo: `#{url}`.", :blue
      error("Invalid url: `#{url}`.") if url.nil?
      cmd = if recursive
        "git clone --recursive \"#{url}\" \"#{dst_path}\""
      else
        "git clone \"#{url}\" \"#{dst_path}\""
      end
      exec_cmd(cmd, as_su: !existing_dir(File.dirname(dst_path)))
    end

    # }}}

    # }}}

    # {{{ Meta

    ##
    # Return the normalized and validated meta object.
    #
    # Be sure to call `setup_vars` before calling this method.
    #
    def get_meta(meta_path, vars_path, tmp_path, elems_base_path, verbose) # {{{
      say 'Getting meta informations.', :blue

      meta = YAML.load(File.read(meta_path))
      meta["all_elems_count"] = meta['elems'].count

      # {{{ Step 1: Normalize elements

      elem_erb_excluded_fields = ['only']

      meta['elems'] = meta['elems'].each_with_index.collect do |elem, idx|
        elem_identifier = elem['name'] || "src = #{elem['src']}"
        info("\nElement: ", elem_identifier) if verbose

        # Step 1.1: Validate `only` and determine if the element is selected.
        if elem.has_key?('only') && !elem['only'].is_a?(Hash)
          error "The configuration element `#{elem_identifier}` has invalid " +
                "`only`: it's not a `Hash`."
        end
        selected = selected_by_only?(elem['only'], verbose)

        # Step 1.2: Pre-process strings with ERB.
        if selected
          elem.each do |k, v|
            unless elem_erb_excluded_fields.include? k
              elem[k] = ERB.new(v).result(binding)
            end
          end
        end

        # Step 1.3: Validate and normalize `name`, `src`, `dst`, `fs_maps`.
        if selected
          unless elem.has_key?('src')
            error "Element `#{elem_identifier}` doesn't contain `src`."
          end
          unless elem.has_key?('name')
            elem['name'] = elem['src']
          end
          unless elem.has_key?('dst')
            error "Element `#{elem_identifier}` doesn't contain `dst`."
          end
          elem['fs_maps'] = []
        end

        selected ? elem : nil
      end.compact

      # Step 1.4: For each active elem, match the `src` field against the
      #           filesystem and determine filesystem mapping (`fs_maps`).
      meta['elems'].each do |elem|
        found = false

        Find.find(elems_base_path).select {|ebp| File.file? ebp }
            .each do |subfile_path|
          subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
            Pathname.new(elems_base_path)).to_s
          if md = Regexp.new(elem['src']).match(subfile_rel_path.gsub(/\.tt$/, ''))
            found = true
            dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
              idx = Integer($1)
              unless (1..md.length) === idx
                error "Invalid 'dst' for element `#{elem['name']}`: nothing " +
                      "captured at index `#{idx}`."
              else
                md[idx]
              end
            end
            elem['fs_maps'] << {
              'src_path' => File.expand_path(subfile_path),
              'dst_path' => File.expand_path(dst_path)
            }
          end
        end

        unless found
          warning "Inconsistency found for elem `#{elem['name']}`: no file " +
                  "matches src: `#{elem['src']}`."
        end
      end

      # }}}

      # {{{ Step 2: Normalize commands

      command_excluded_erb_fields = ['only']

      meta['commands'] = meta['commands'].each_with_index.collect do |spec, idx|
        spec['name'] ||= "type = #{spec['type']}, index = #{idx}"
        info("\nCommand: ", spec['name']) if verbose

        # Step 2.1: Validate 'only' and determine if the command is selected.
        if spec.has_key?('only') && !spec['only'].is_a?(Hash)
          error "The command `#{spec['name']}` has invalid `only`: it's not " +
                'a `Hash`.'
        end
        selected = selected_by_only?(spec['only'], verbose)

        if selected

          # Step 2.2: Pre-process strings with ERB.
          spec.each do |key, value|
            unless command_excluded_erb_fields.include? key
              spec[key] = ERB.new(value).result(binding)
            end
          end

          # Step 2.3: Validate `type`, `validator`, `executor`.
          if !spec.has_key?('type') ||
             !available_commands.keys.include?(spec['type'])
            error "The command `#{spec['name']}` has invalid `type`: it's " +
                  "not in `#{available_commands.keys}`."
          end
          command = available_commands[spec['type']]
          if command.has_key?('validator') && !command['validator'].is_a?(Proc)
            error "Invalid validator for command `#{spec['name']}`: if " +
                  "provided it should be a `Proc`."
          end
          if !command.has_key?('executor') || !command['executor'].is_a?(Proc)
            error "Invalid executor for command `#{spec['name']}`: it should " +
                  'be a `Proc`.'
          end

          # Step 2.4: Use type-specific validator if it's defined.
          if command.has_key?('validator') && (
               !command['validator'].is_a?(Proc) ||
               !command['validator'].call(spec)
             )
            error "The validator for command `#{spec['name']}` didn't pass."
          end

        end

        selected ? spec : nil
      end.compact

      # }}}

      # Build the list of excluded files (needed by Thor's `directory()`).
      all_files = Set.new(Find.find(elems_base_path).select { |f| File.file? f})
      src_paths = Set.new(
        meta['elems'].collect_concat do |elem|
          elem['fs_maps'].collect { |m| m['src_path'] }
        end
      )
      vars_files = Dir.glob(File.join(vars_path, '*'), File::FNM_DOTMATCH)
      meta['system_files'] = Set.new(vars_files << meta_path)
      meta['excluded_files'] = all_files - src_paths - meta['system_files']
      meta['all_files_count'] = all_files.count

      meta
    end # }}}

    ##
    # Return whether the provided `only` specification is evaluated as an allows
    # and not as a denies.
    #
    def selected_by_only?(only, verbose) # {{{
      unless only
        selected = true
        info(' ↳ ', "#{set_color('✔', :green)} (`only` is empty).") if verbose
      else
        wants_features = only.has_key?('features')
        wants_vars     = only.has_key?('vars')

        feat_ok = if wants_features
                    only['features'].any? do |feature|
                      case feature
                      when Array
                        feature.all? { |f| has_feature? f }
                      else
                        has_feature? feature
                      end
                    end
                  else
                    true
                  end
        vars_ok = wants_vars ?
            only['vars'].any? { |var| !get_var(var).nil? } :
            true

        selected   = !wants_features && !wants_vars
        selected ||= (feat_ok && vars_ok)

        if selected && verbose
          info ' ↳ ', "#{set_color('✔', :green)} (`only` is present and " +
                      'satisfied).'
        end
      end

      if !selected && verbose
        info ' ↳ ', "#{set_color('✘', :red)} (`only` is present and didn't " +
                    'match).'
      end

      selected
    end # }}}

    # }}}

    # {{{ Variables

    attr_reader :vars

    ##
    # Setup the variables that will be used during ERB processing.
    #
    # Those variables will be set into an instance field called `@vars`.
    #
    # After calling this method, you can directly access the variables using
    # `@vars` or using the attribute reader `vars`.
    #
    def setup_vars(vars_path, vars_file_name) # {{{
      say 'setting up vars', :blue
      vars = {}
      dummy_names_regex = /none|nothing/i
      inherits_regex = /#=>\s*inherits:\s*(?<inherits_name>[^\s]+)\s*<=#/i
      nesting = 0

      read_vars_file = lambda do |file_name|
        inherit_str = nesting == 0 ?
                        'vars tree: ' :
                        ' ' * (11 + (nesting - 1) * 2) + '↳ '
        info inherit_str, file_name
        file_path = File.join(vars_path, "#{file_name}.yml")
        file_content = File.read(file_path)

        # Find the name of the file to be inherited.
        inherits_name = file_content.match(inherits_regex)[:inherits_name]

        # Load the file that should be inherited (if any) by calling this
        # function recursively and merging the read variables into `vars`.
        if inherits_name && !(inherits_name =~ dummy_names_regex)
          inherits_file_path = File.join(vars_path, "#{inherits_name}.yml")
          unless File.file?(inherits_file_path)
            error "Inherited variables file doesn't exist: `#{inherits_name}`"
          end
          nesting += 1
          vars = vars.deep_merge(read_vars_file.call(inherits_name))
        end

        # Base case: read the yaml file (parsing possible erb template
        # icecreams) and store the read variables into `vars`.
        vars = vars.deep_merge(YAML.load(ERB.new(file_content).result) || {})
      end

      read_vars_file.call(vars_file_name)

      @vars = vars

      say ''
    end # }}}

    ##
    # Return the variable matching the provided `name`.
    #
    # The variables object being looked up is the one returned from the
    # method `vars`.
    #
    def get_var(var_name) # {{{
      dot_split_regexp = /([^.]+)(?:\.|$)/
      var_name.to_s
          .scan(dot_split_regexp).map { |match_group| match_group[0] }
          .reject(&:empty?)
          .inject(vars) do |cur_obj, name_component|

        nxt_obj = if cur_obj.has_key?(name_component)
          cur_obj[name_component]
        else
          nil
        end
        nxt_obj or break nil
      end
    end # }}}

    ##
    # Same of `get_var`, but raise an error if the variable hasn't been found or
    # is `nil`.
    #
    def get_var!(var_name) # {{{
      get_var(var_name) or error("Undefined or `nil` variable: `#{var_name}`.")
    end # }}}

    ##
    # Check if the feature with the provided name (`feature_name`) is enabled.
    #
    # Since the features are defined just using variables, before calling this
    # method be sure that `setup_vars` has already been called.
    #
    def has_feature?(feature_name) # {{{
      get_var!('features').include? feature_name.to_s
    end # }}}

    ##
    # Filter the values associated to the features, keeping only those
    # associated to available features.
    #
    def data_for_features(info)
      data = []
      info.each do |feature_name, associated_value|
        if has_feature?(feature_name.to_sym)
          if associated_value.respond_to?(:call)
            data << associated_value.call
          else
            data << associated_value
          end
        end
      end
      data
    end

    # }}}

    # {{{ Host environment / system

    ##
    # Return the environment variable matching the provided `name`.
    #
    def get_env(name) # {{{
      ENV[name.to_s]
    end # }}}

    ##
    # Same of `get_env`, but raise an error if the environment variable hasn't
    # been found or is `nil`.
    #
    def get_env!(name) # {{{
      get_env(name) or error("Undefined environment variable: `#{name}`")
    end # }}}

    ##
    # Check if the underlying operating system is MacOSX.
    #
    def is_osx? # {{{
      RUBY_PLATFORM_IS_OSX
    end # }}}

    ##
    # Check if the underlying operating system is GNU/Linux.
    #
    def is_linux? # {{{
      RUBY_PLATFORM_IS_LINUX
    end # }}}

    # }}}

    # {{{ Commands execution

    ##
    # Execute the provided shell command (`cmd`).
    #
    # If `as_su` is `true` the command is executed as super user (i.e. as root,
    # using sudo).
    #
    def exec_cmd(cmd, as_su: false) # {{{
      full_cmd = as_su ? "sudo #{cmd}" : cmd

      really_run = case @run_mode
        when :normal then true
        when :paranoid then quiz("Do you want to run command `#{full_cmd}`")
        when :dry then false
        else true
      end

      if really_run || @run_mode == :dry
        say (as_su ? "[sudo] #{cmd}" : cmd), :magenta
      end

      if really_run
        system(full_cmd) || warning("Command `#{full_cmd}` failed.")
      end
    end # }}}

    # }}}

    # {{{ Filesystem

    ##
    # Check if the provided `path` is an existing directory.
    #
    # If `writable` is true, also check if `path` points to a writable
    # directory.
    #
    def existing_dir(path, writable: true) # {{{
      dir_path = path
      while !File.directory?(dir_path)
        dir_path = File.dirname(dir_path)
      end
      (writable && !File.writable?(dir_path)) ? nil : dir_path
    end # }}}

    ##
    # Return an object (`OpenStruct`), which contains all of the well-known
    # paths.
    #
    # Before adding a path, some validations are executed to ensure that path
    # points to a correct thing.
    #
    # You can skip some validations and filling some paths:
    # - `valid_cfg`: If `false` don't validate and fill paths related to the
    #                configuration.
    # - `valid_inst`:
    #   - If `false` don't validate and fill paths related to the configuration
    #     instances.
    #   - If `true`, be sure to provide the argument `cur_inst_name`, which
    #     should contain the name of the current instance (the instance that
    #     should be used).
    #
    def prepare_storage(root_path, valid_cfg: true, valid_inst: true, cur_inst_name: nil) # {{{
      root_path = File.expand_path(root_path)

      # Paths based on internal conventions.
      parent_path        = File.dirname(root_path)
      tmp_path           = File.join(root_path, 'tmp')

      cfg_path           = File.join(root_path, 'cfg')
      cfg_vars_path      = File.join(cfg_path,  'vars')
      cfg_meta_path      = File.join(cfg_path,  'meta.yml')

      inst_path          = File.join(root_path, 'inst')
      cur_inst_path      = cur_inst_name && File.join(inst_path, cur_inst_name)
      cur_inst_vars_path = cur_inst_path && File.join(cur_inst_path, 'vars')
      cur_inst_meta_path = cur_inst_path && File.join(cur_inst_path, 'meta.yml')

      # Validate storage correctness.
      if ((File.directory?(root_path)  && !File.writable?(root_path)) ||
          File.file?(root_path)                                       ||
          (!File.directory?(root_path) && !File.writable?(parent_path)))
        error "No write permissions in Fizzy storage at path `#{root_path}`."
      end
      if ((File.directory?(tmp_path) && !File.writable?(tmp_path)) ||
          File.file?(tmp_path))
        error "The temporary directory `#{tmp_path}` already exists but is " +
              'not writable.'
      end
      if valid_cfg
        if !File.directory?(root_path)
          error "The Fizzy root directory `#{root_path}` doesn't exist " +
                '(maybe you need to run: `fizzy cfg sync`).'
        end
        if !File.directory?(cfg_path) || !File.writable?(cfg_path)
          error "The configuration directory `#{cfg_path}` already exists " +
                'but is not writable.'
        end
        if !File.file?(cfg_meta_path)
          error "The configuration directory `#{cfg_meta_path}` is invalid: " +
                'not a valid meta file.'
        end
        if !File.directory?(cfg_vars_path)
          error "The variables directory `#{cfg_vars_path}` is invalid: " +
                "doesn't exist."
        end
      end
      if valid_inst
        if !File.directory?(root_path)
          error "The Fizzy root directory `#{root_path}` doesn't exist " +
                '(maybe you need to run: `fizzy cfg sync`).'
        end
        if !File.directory?(cur_inst_path) || !File.writable?(cur_inst_path)
          error "The current instance `#{cur_inst_name}` is stored in an "  +
                "invalid path (`#{cur_inst_path}`): already exists but is " +
                'not writable.'
        end
        if !File.file?(cur_inst_meta_path)
          error "The meta file path (`#{cur_inst_meta_path}`) for the "    +
                "current instance `#{cur_inst_name}` is invalid: doesn't " +
                "exist or isn't a regular file."
        end
        if !File.directory?(cur_inst_vars_path)
          error "The variables directory (`#{cur_inst_vars_path}`) for the " +
                "current instance `#{cur_inst_name}` is invalid: doesn't "   +
                "exist or isn't a directory."
        end
      end

      # Create non-existing internal directories.
      FileUtils.mkdir_p(root_path)     unless File.directory?(root_path)
      FileUtils.mkdir_p(tmp_path)      unless File.directory?(tmp_path)
      FileUtils.mkdir_p(inst_path)     unless File.directory?(inst_path)
      FileUtils.mkdir_p(cur_inst_path) if cur_inst_path &&
                                          !File.directory?(cur_inst_path)

      # Return the known storage paths.
      OpenStruct.new(
        :root          => root_path,
        :tmp           => tmp_path,
        :cfg           => cfg_path,
        :cfg_vars      => cfg_vars_path,
        :cfg_meta      => cfg_meta_path,
        :inst          => inst_path,
        :cur_inst      => cur_inst_path,
        :cur_inst_vars => cur_inst_vars_path,
        :cur_inst_meta => cur_inst_meta_path)
    end # }}}

    # }}}

    # {{{ I/O & Error handling

    ##
    # Ask a question to the user.
    #
    # The message is made by the `question` string, with some additions (like
    # `?` sign).
    #
    # The available quiz types are:
    # - `:bool`: Boolean quiz, the user can respond with `yes` or `no` (or
    #            alternatives, see regexes below). A boolean value is returned.
    # - `:string`: Normal quiz, the user is prompt for a question and if the
    #              answer isn't empty is returned.
    #
    def quiz(question, type: :bool) # {{{
      answer = ask "#{question.strip}? ", :magenta
      case type
      when :bool
        if answer =~ /y|ye|yes|yeah|ofc/i
          true
        elsif answer =~ /n|no|fuck|fuck\s+you|fuck\s+off/i
          false
        else
          say 'Answer misunderstood', :yellow
          quiz(question, :type => type)
        end
      when :string
        if answer.empty?
          warning 'Empty answer', :ask_continue => false
          quiz(question, :type => type)
        else
          answer
        end
      else
        error "Unhandled question type: `#{type}`."
      end
    end # }}}

    ##
    # Display an informative message (`msg`) to the user.
    #
    # The `prefix` argument should contain some text displayed before the
    # message, typically to show the context which the message belongs to.
    #
    def info(prefix, msg) # {{{
      say("☞ #{set_color(prefix, :cyan)}#{set_color(msg, :white)}")
    end # }}}

    ##
    # Display an informative message (`msg`) to the user.
    #
    # If `ask_continue` is `true`, the user can interactively choose to stop
    # the program or exit (with exit status `-1`).
    #
    def warning(msg, ask_continue: true) # {{{
      say "⚠ #{msg}", :yellow
      exit(-1) if ask_continue && !quiz('continue')
    end # }}}

    ##
    # Display an error message (`msg`) to the user. Before returning, the
    # program will exit (with exit status `-1`).
    #
    def error(msg) # {{{
      say "☠ #{msg}", :red
      exit(-1)
    end # }}}

    # }}}

  end # }}}


  class FizzyCommand < Thor # {{{

    include Thor::Actions
    include Fizzy::Utils

    protected

    ##
    # Return a list of functions capable to apply modifications on the system
    # based on the current elements configuration instance.
    #
    # In particular, an applier work for each element installed.
    #
    def elements_appliers # {{{
      [ lambda { |elem| # Create parent directories.
          elem['fs_maps'].each do |m|
            parent_dir = File.dirname(m['dst_path'])
            if elem.has_key?('perms')
              l_ex_dir_path = f_noex_dir_path = parent_dir
              while !File.directory?(l_ex_dir_path)
                f_noex_dir_path = l_ex_dir_path
                l_ex_dir_path   = File.dirname(l_ex_dir_path)
              end
            else
              l_ex_dir_path = f_noex_dir_path = nil
            end
            # From here, we have the following variable set:
            # - `l_ex_dir_path`: Longest path prefix which points to an existing
            #                    directory.
            # - `f_noex_dir_path`: Path of the first directory after the prefix
            #                      which points to an existing dir.
            if !File.directory?(parent_dir)
              exec_cmd("mkdir -p \"#{parent_dir}\"",
                       :as_su => !existing_dir(parent_dir))
              if elem.has_key?('perms') && (l_ex_dir_path != f_noex_dir_path)
                exec_cmd("chmod -R \"#{elem['perms']}\" \"#{f_noex_dir_path}\"",
                         :as_su => !File.owned?(f_noex_dir_path))
              end
            end
          end
        },
        lambda { |elem| # Create a symlink for each elements' `src_path`.
          elem['fs_maps'].each do |m|
            say "  #{m['src_path']} ← #{m['dst_path']}" if @verbose
            cmd = 'ln -s'
            should_link = if File.file?(m['dst_path'])
              dst_real_path = Pathname.new(m['dst_path']).realpath.to_s
              if dst_real_path != m['src_path']
                cmd << ' -f'
                quiz "The destination file `#{m['dst_path']}` already " +
                     'exists. Overwrite'
              else
                false
              end
              elsif File.directory?(m['dst_path'])
                if quiz "The destination file `#{m['dst_path']}` is a " +
                        'directory. Delete it'
                  exec_cmd("rm -Rf #{m['dst_path']}",
                           :as_su => !existing_dir(File.dirname(m['dst_path'])))
                end
              else
              # Link does not exist yet.
              true
            end

            if should_link
              cmd << " \"#{m['src_path']}\" \"#{m['dst_path']}\""
              exec_cmd(cmd,
                       :as_su => !existing_dir(File.dirname(m['dst_path'])))
            end
          end
        }
      ]
    end # }}}

    ##
    # Return a data structure containing the commands that can be specified in
    # the meta file.
    #
    # The data structure defines:
    # - The available command types (`available_commands.keys`).
    # - (Optionally) A validator that can be used to validate type-specific
    #   validation rules.
    # - The command executor: A `Lambda` containing the code used for executing
    #   that command.
    #
    def available_commands # {{{
      { 'git_sync' => {
          'validator' => lambda { |spec|
            if spec.has_key?('dst')
              spec['dst'] = File.expand_path(spec['dst'])
            end
            status   = spec.has_key?('repo')
            status &&= spec.has_key?('dst')
          },
          'executor' => lambda { |spec|
            if File.directory?(spec['dst'])
              FileUtils.cd(spec['dst']) { git_pull }
            else
              git_clone(spec['repo'], spec['dst'])
            end
          }
        }
      }
    end # }}}

  end # }}}


  # {{{ Subcommands

  class Inst < FizzyCommand # {{{

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    desc 'cd INST_NAME', 'Change directory to the instance directory (useful for ' +
                         'extensive filesystem manipulations).'
    def cd(inst_name) # {{{
      # Prepare stuff for changing directory.
      paths = prepare_storage(options.fizzy_dir, :cur_inst_name => inst_name)

      # Changing directory.
      say "Changing directory to: `#{paths.cur_inst}`.", :cyan
      FileUtils.cd(paths.cur_inst)
      if ENV.has_key?('SHELL')
        system(ENV['SHELL'])
      else
        error 'Cannot find a valid shell. The environment variable `SHELL`' +
              'is unset.'
      end

      # Inform user about the changing directory status.
      say "CD done in: `#{paths.cur_inst}`.", :green
    end # }}}
    
  end # }}}
  
  class Cfg < FizzyCommand # {{{

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    desc 'cleanup', 'Cleanup the Fizzy storage (i.e. configuration, ' +
                    'instances, tmp files).'
    def cleanup # {{{
      # Prepare paths for cleanup.
      paths = prepare_storage(options.fizzy_dir,
                              :valid_cfg => false, :valid_inst => false)

      # Perform cleanup.
      status = if quiz 'Do you want to remove the Fizzy root directory' +
                       "`#{paths.root}`"
        exec_cmd("rm -Rf \"#{paths.root}\"")
      else
        nil
      end

      # Inform user about the cleanup status.
      if status
        say "Successfully cleaned: `#{paths.root}`.", :green
      elsif status.nil?
        warning 'Cleanup skipped.', :ask_continue => false
      else
        error "Failed to cleanup: `#{paths.root}`.", :red
      end
    end # }}}

    desc 'import', 'Import an existing configuration.'
    def import # {{{
      error('WIP, check later!')
    end # }}}

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    desc 'cd', 'Change directory to the configuration directory (useful for ' +
               'extensive filesystem manipulations).'
    def cd # {{{
      # Prepare stuff for changing directory.
      paths = prepare_storage(options.fizzy_dir, :valid_inst => false)

      # Changing directory.
      say "Changing directory to: `#{paths.cfg}`.", :cyan
      FileUtils.cd(paths.cfg)
      if ENV.has_key?('SHELL')
        system(ENV['SHELL'])
      else
        error 'Cannot find a valid shell. The environment variable `SHELL`' +
              'is unset.'
      end

      # Inform user about the changing directory status.
      say "CD done in: `#{paths.cfg}`.", :green
    end # }}}

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    desc 'edit CFG_NAME', 'Find the files relative to CFG_NAME and edit them.'
    def edit(cfg_name) # {{{
      # Prepare stuff for editing.
      paths = prepare_storage(options.fizzy_dir, :valid_inst => false)
      find_path = File.join(paths.cfg, cfg_name)
      cfg_files_arg = (File.exist?(find_path) ?
          "\"#{find_path}\"" :
          Dir.glob("#{find_path}*", File::FNM_DOTMATCH).to_a
              .delete_if { |path| path =~ /\.git/ }
              .collect { |path| "\"#{path}\"" }
              .join(' ')
      ).strip
      editor = ENV['EDITOR'] || $DEF_EDITOR

      # Perform edit
      if cfg_files_arg.empty?
        warning "No files matching `#{cfg_name}` have been found.", :ask_continue => false
        status = nil
      else
        say "Editing configuration file(s): `#{cfg_files_arg}`.", :cyan
        status = system("#{editor} #{cfg_files_arg}")
      end

      # Inform user about the editing status.
      if status
        say "Successfully edited: `#{cfg_files_arg}`.", :green
      elsif status.nil?
        warning 'Editing skipped.', :ask_continue => false
      else
        error "Failed to edit: `#{cfg_files_arg}`.", :red
      end
    end # }}}

    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :url, :default => nil,
           :desc => 'The url to the repository holding config (currently ' +
                    'supported: `git`)'
    desc 'sync', 'Synchronize the remote repository with the local one.'
    def sync # {{{
      # Prepare stuff for syncing.
      paths = prepare_storage(options.fizzy_dir,
                              :valid_cfg => false, :valid_inst => false)

      # Perform sync.
      sync_result = if File.directory?(paths.cfg)
        say 'Syncing from origin', :blue
        status = nil
        FileUtils.cd(paths.cfg) do
          # Perform fetch, because we need to know if there are remote changes,
          # so we need to know the updated remote commit hash.
          say 'Fetching informations from origin', :cyan
          status = system('git fetch origin')
          # (Optional) Perform commit.
          if status && git_has_local_changes(paths.cfg)
            say "The configuration has the following local changes:\n" +
                "#{set_color(git_local_changes(paths.cfg), :white)}", :cyan
            should_commit = quiz 'Do you want to commit them all'
            if should_commit
              commit_msg = quiz 'Type the commit message', :type => :string
              say 'Performing commit.', :cyan
              status   = system('git add -A')
              status &&= system("git commit -am \"#{commit_msg}\"")
            else
              status = false
            end
          end
          # (Optional) Perform pull.
          if status && git_should_pull(paths.cfg)
            status = git_pull
          end
          # (Optional) Perform push.
          if status && git_should_push(paths.cfg)
            say 'Performing push.', :cyan
            status = system('git push origin master')
          end
        end
        status
      else
        git_clone(options.url, paths.cfg)
      end

      # Inform user about sync status.
      if sync_result
        say "Synced to: `#{paths.cfg}`.", :green
      else
        error 'Unable to sync.'
      end
    end # }}}

    option :vars_name, :required => true,
           :desc => 'The name for the variables file to be used.'
    option :inst_name, :required => true,
           :desc => 'The name for the new configuration instance.'
    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :verbose, :type => :boolean, :default => false,
           :desc => 'Whether the output should be verbose.'
    desc 'instantiate',
         'Create a configuration instance in the current machine.'
    def instantiate # {{{
      # Before instantiation.
      paths = prepare_storage(options.fizzy_dir,
                              :valid_inst    => false,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cfg_vars, options.vars_name)

      meta = get_meta(
        paths.cfg_meta, paths.cfg_vars, paths.tmp, paths.cfg, options.verbose)

      info 'meta: ', "#{set_color(meta['elems'].count, :green)}/" +
                     "#{meta['all_elems_count']} elem(s) selected."
      info 'meta: ', "#{set_color(meta['excluded_files'].count, :red)}/" +
                     "#{meta['all_files.count']} file(s) excluded."
      say

      # Create a configuration instance.
      say "Creating a configuration instance named `#{options.inst_name}` " +
          "from: `#{paths.cfg}`.", :blue

      exclude_pattern = /\.git|README/
      meta['excluded_files'].each do |excluded_file|
        exclude_pattern = /#{exclude_pattern}|#{excluded_file}/
      end

      begin
        directory(paths.cfg, paths.cur_inst, :exclude_pattern => exclude_pattern)
      rescue SyntaxError
        error "Error while processing the template: `#{$fizzy_cur_template}`."
      end

      # After instantiation.
      say "Created the configuration instance in: `#{paths.cur_inst}`.", :green
    end # }}}

    def self.source_root; '/' end

  end # }}}

  class Sys < FizzyCommand # {{{

    option :vars_name, :required => true,
           :desc => 'The name for the variables file to be used.'
    option :inst_name, :required => true,
           :desc => 'The name for the new configuration instance.'
    option :fizzy_dir, :default => $DEF_FIZZY_DIR,
           :desc => 'The root path for the directory internally used by Fizzy.'
    option :run_mode, :default => 'normal',
           :enum => ['normal', 'paranoid', 'dry'],
           :desc => 'Ask confirmation for each filesystem operation.'
    option :verbose, :type => :boolean, :default => false,
           :desc => 'If the output should be verbose.'
    desc 'install', 'Install the current configuration instance in the system.'
    def install # {{{
      # Prepare stuff for performing install.
      @run_mode = options.run_mode.to_sym
      @verbose = options.verbose
      paths = prepare_storage(options.fizzy_dir,
                              :cur_inst_name => options.inst_name)
      setup_vars(paths.cur_inst_vars, options.vars_name)

      meta = get_meta(
        paths.cur_inst_meta, paths.cur_inst_vars,
        paths.tmp, paths.cur_inst, options.verbose)

      # Install the instance into the system.
      say "Installing the configuration instance `#{options.inst_name}` " +
          "into the system.", :blue
      FileUtils.cd(paths.tmp) do # Stay in a safe place.
        meta['elems'].each do |elem|
          say "Installing element: `#{elem['name']}`.", :cyan
          elements_appliers.each { |applier| applier.call(elem) }
          if elem['notes']
            say "Notes for `#{elem['name']}`:", :yellow
            say elem['notes'].split("\n").collect { |s|
              "  #{s}"
            }.join("\n")
          end
        end
        meta['commands'].each do |spec|
          say "Executing command: `#{spec['name']}`.", :cyan
          available_commands[spec['type']]['executor'].call(spec)
        end
      end

      # Inform the user about installation status.
      say "The configuration instance `#{options.inst_name}` has been " +
          'installed into the system', :green
    end # }}}

  end # }}}

  # }}}


  class Main < Thor # {{{

    include Fizzy::Utils

    desc 'cfg SUBCOMMAND ...ARGS',
         'Manage the Fizzy configuration (without modifying the host system).'
    subcommand 'cfg', Cfg

    desc 'inst SUBCOMMAND ...ARGS', 'Manage a configuration instance'
    subcommand 'inst', Inst
    
    desc 'sys SUBCOMMAND ...ARGS',
         'Manage the system integration with the available Fizzy configuration'
    subcommand 'sys', Sys

    desc 'usage', 'Show how to use Fizzy.'
    def usage
      url = 'https://raw.githubusercontent.com/alem0lars/fizzy/master/README.md'
      res = Net::HTTP.get_response(URI(url))
      if res.is_a?(Net::HTTPSuccess)
        say "\n#{res.body}\n"
      else
        error "Network error: cannot retrieve `#{url}`."
      end
    end

  end # }}}

end


# Entry point.
Fizzy::Main.start(ARGV)

#!/usr/bin/env ruby


# requires {{{

require 'fileutils'
require 'find'
require 'ostruct'
require 'net/http'
require 'pathname'
require 'yaml'

begin
  require 'thor'
rescue
  puts '[error] thor is not installed'
  exit(-1)
end

# }}}


module Fizzy

  module Utils # {{{

    def setup_vars(paths, def_vars_name, vars_name)
      paths.def_vars_file = File.join(paths.vars, "#{def_vars_name}.yml")
      paths.vars_file     = File.join(paths.vars, "#{vars_name}.yml")
      def_vars = YAML.load(ERB.new(File.read(paths.def_vars_file)).result)
      vars     = YAML.load(ERB.new(File.read(paths.vars_file)).result)
      all_vars = {'features' => []}.merge(def_vars).merge(vars)
      OpenStruct.new(all_vars)
    end

    def exec_cmd(cmd, as_su: false)
      if as_su
        say "[sudo] #{cmd}", :magenta
      else
        say cmd, :magenta
      end
      system(as_su ? "sudo #{cmd}" : cmd)
    end

    def existing_dir(path, writable: true)
      dir_path = path
      while !File.directory?(dir_path)
        dir_path = File.dirname(dir_path)
      end
      (writable && !File.writable?(dir_path)) ? nil : dir_path
    end

    def error(msg)
      say msg, :red
      exit(-1)
    end

    def prepare_storage(root_path, valid_cfg: true, cur_inst_name: nil)
      # paths based on internal conventions
      parent_path = File.expand_path(File.dirname(root_path))
      tmp_path    = File.join(root_path, 'tmp')
      cfg_path    = File.join(root_path, 'cfg')
      vars_path   = File.join(cfg_path,  'vars')
      inst_path   = File.join(root_path, 'inst')
      meta_path   = File.join(inst_path, 'meta.yml')

      # validate storage correctness
      if ((File.directory?(root_path)  && !File.writable?(root_path)) ||
          File.file?(root_path)                                       ||
          (!File.directory?(root_path) && !File.writable?(parent_path)))
        error("no write perms in fizzy storage: #{root_path}")
      end
      if ((File.directory?(tmp_path) && !File.writable?(tmp_path)) ||
          File.file?(tmp_path))
        error('tmp dir already exists but is not writable')
      end
      if valid_cfg
        if !File.directory?(cfg_path) || !File.writable?(cfg_path)
          error('config dir already exists but is not writable')
        end
        if !File.file?(meta_path)
          error("config is invalid: '#{meta_path}' isn't a valid meta file")
        end
        if !File.directory?(vars_path)
          error("invalid vars directory: '#{vars_path}' doesn't exist")
        end
      end
      if ((File.directory?(inst_path) && !File.writable?(inst_path)) ||
          File.file?(inst_path))
        error('instance dir already exists but is not writable')
      end

      # create non-existing internal directories
      FileUtils.mkdir_p(root_path) unless File.directory?(root_path)
      FileUtils.mkdir_p(tmp_path)  unless File.directory?(tmp_path)
      FileUtils.mkdir_p(inst_path) unless File.directory?(inst_path)

      # return the known storage paths
      OpenStruct.new(
        :root     => root_path,
        :tmp      => tmp_path,
        :cfg      => cfg_path,
        :vars     => vars_path,
        :inst     => inst_path,
        :meta     => meta_path,
        :cur_inst => cur_inst_name ? File.join(inst_path, cur_inst_name) : nil)
    end

  end # }}}


  # subcommands {{{

  class Cfg < Thor # {{{

    include Thor::Actions
    include Fizzy::Utils

    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    option :url, :default => nil,
           :desc => 'the url to the repository holding config (suppored: git)'
    desc 'sync', 'synchronize the remote repository with the local one'
    def sync
      # before sync
      paths = prepare_storage(options.fizzy_dir, :valid_cfg => false)

      # perform sync
      sync_result = if File.directory?(paths.cfg)
        say 'syncing from origin', :blue
        status = nil
        FileUtils.cd(paths.cfg) do
          say 'performing pull', :cyan
          status = system('git pull origin master')
          if status
            say 'performing push', :cyan
            status = system('git push origin master')
          end
        end
        status
      else
        say "syncing from remote repo: '#{options.url}'", :blue
        error('invalid url option') if options.url.nil?
        system("git clone #{options.url} #{paths.cfg}")
      end

      # after sync
      if sync_result
        say "synced to: #{paths.cfg}", :green
      else
        error('unable to sync')
      end
    end

    option :def_vars_name, :default => 'generic',
           :desc => 'the name for the default variables file'
    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'instantiate', 'create a configuration instance in the current machine'
    def instantiate
      # before instantiation
      paths = prepare_storage(options.fizzy_dir,
                              :valid_inst => false,
                              :cur_inst_name => options.inst_name)

      # create a configuration instance
      @vars = setup_vars(paths, options.def_vars_name, options.vars_name)
      say "creating a configuration instance named '#{options.inst_name}' " +
          "from: #{paths.cfg}", :blue
      directory(paths.cfg, paths.cur_inst, :exclude_pattern => /\.git|README/)

      # after instantiation
      say "created the configuration instance in: #{paths.cur_inst}", :green
    end

    def self.source_root; '/' end

  end # }}}

  class Sys < Thor # {{{

    include Fizzy::Utils

    option :def_vars_name, :default => 'generic',
           :desc => 'the name for the default variables file'
    option :vars_name, :required => true,
           :desc => 'the name for the variables file to be used'
    option :inst_name, :required => true,
           :desc => 'the name for the new configuration instance'
    option :fizzy_dir, :default => '/var/tmp/fizzy',
           :desc => 'the root path for the directory internally used by fizzy'
    desc 'install',
         'install the current configuration instance in the system'
    def install
      # before install
      paths = prepare_storage(options.fizzy_dir,
                              :cur_inst_name => options.inst_name)
      # -> validate meta informations
      meta = YAML.load(ERB.new(File.read(paths.meta)).result)
      error("invalid meta: 'elems' key not found") unless meta.has_key?('elems')
      unless meta['elems'].respond_to?(:each_with_index)
        error("invalid meta: 'elems' is not iterable")
      end
      meta['elems'].each_with_index do |elem, idx|
        error("elem '#{idx}' isn't a hash") unless elem.is_a?(Hash)
        unless elem.has_key?('src')
          error("elem '#{elem['name'] || "idx=#{idx}"}' doesn't contain 'src'")
        end
        unless elem.has_key?('name')
          error("elem 'idx=#{idx}' doesn't contain 'name'")
        end
        unless elem.has_key?('dst')
          error("elem '#{elem['name']}' doesn't contain 'dst'")
        end
        if elem.has_key?('only') && !elem['only'].is_a?(Array)
          error("elem '#{elem['name']}' has invalid 'only': it's not an array")
        end
      end
      # -> prepare install
      meta['elems'] = normalize_elems(meta, paths)

      # perform install
      say "installing the configuration instance '#{options.inst_name}' " +
          "into the system", :blue
      @vars = setup_vars(paths, options.def_vars_name, options.vars_name)
      FileUtils.cd(paths.tmp) do # stay in a safe place
        meta['elems'].each do |elem|
          elem_enabled = elem['only'].any? { |o| @vars.features.include?(o) }
          if !elem.has_key?('only') || elem_enabled
            say "installing elem: '#{elem['name']}'", :cyan
            appliers.each { |applier| applier.call(elem) }
            if elem['notes']
              say "notes for '#{elem['name']}:", :yellow
              say elem['notes']
            end
          end
        end
      end

      # after instantiation
      say 'the configuration instance has been intalled into the system', :green
    end

    protected

    def normalize_elems(meta, paths)
      elems = []
      FileUtils.cd(paths.tmp) do # stay in a safe place
        Find.find(paths.cur_inst).each do |subfile_path|
          subfile_rel_path = Pathname.new(subfile_path).relative_path_from(
              Pathname.new(paths.cur_inst)).to_s
          meta['elems'].each do |elem|
            if md = Regexp.new(elem['src']).match(subfile_rel_path)
              dst_path = elem['dst'].gsub(/<([0-9]+)>/) do
                idx = Integer($1)
                unless (1..md.length) === idx
                  error("invalid 'dst' for elem '#{elem['name']}': nothing " +
                        "captured at index '#{idx}'")
                else
                  md[idx]
                end
              end
              elems << elem.merge({
                'src_path' => subfile_path,
                'dst_path' => dst_path
              })
            end
          end
        end
      end
      elems
    end

    ##
    # return a list of functions capable to apply modifications on the system
    # based on the current configuration instance
    #
    # in particular, an applier work for each element installed
    #
    def appliers
      [ lambda { |elem| # mkdir parent directories
          parent_dir = File.dirname(elem['dst_path'])
          if elem.has_key?('perms')
            l_ex_dir_path = f_noex_dir_path = parent_dir
            while !File.directory?(l_ex_dir_path)
              f_noex_dir_path = l_ex_dir_path
              l_ex_dir_path   = File.dirname(l_ex_dir_path)
            end
          else
            l_ex_dir_path = f_noex_dir_path = nil
          end
          if !File.directory?(parent_dir)
            exec_cmd("mkdir -p \"#{parent_dir}\"",
                     :as_su => !existing_dir(parent_dir))
            if elem.has_key?('perms') && (l_ex_dir_path != f_noex_dir_path)
              exec_cmd("chmod -R \"#{elem['perms']}\" \"#{f_noex_dir_path}\"",
                       :as_su => !File.owned?(f_noex_dir_path))
            end
          end
        },
        lambda { |elem| # create link
          cmd = "ln -s \"#{elem['src_path']}\" \"#{elem['dst_path']}\""
          if File.file?(elem['dst_path'])
            say "skipping '#{elem['dst_path']}': already exists", :yellow
          else
            exec_cmd(cmd,
                     :as_su => !existing_dir(File.dirname(elem['dst_path'])))
          end
        }
      ]
    end

  end # }}}

  # }}}


  class Main < Thor # {{{

    include Fizzy::Utils

    desc 'cfg SUBCOMMAND ...ARGS',
         'manage the fizzy configuration'
    subcommand 'cfg', Cfg

    desc 'sys SUBCOMMAND ...ARGS',
         'manage the system integration with the available fizzy configuration'
    subcommand 'sys', Sys

    desc 'usage', 'show how to use fizzy'
    def usage
      url = 'https://raw.githubusercontent.com/alem0lars/fizzy/master/README.md'
      res = Net::HTTP.get_response(URI(url))
      if res.is_a?(Net::HTTPSuccess)
        puts "\n#{res.body}\n"
      else
        puts "network error: cannot retrieve '#{url}'"
      end
    end

  end # }}}

end


# entry point
Fizzy::Main.start(ARGV)
